\documentclass[11pt]{jarticle}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[a4paper,margin=25mm]{geometry}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{ascmac}
\newtheoremstyle{mystyle}% % Name
    {}%                      % Space above
    {}%                      % Space below
    {\normalfont}%           % Body font
    {}%                      % Indent amount
    {\bfseries}%             % Theorem head font
    {}%                      % Punctuation after theorem head
    { }%                     % Space after theorem head, ' ', or \newline
    {}%                      % Theorem head spec (can be left empty, meaning `normal')
\theoremstyle{mystyle}
\usepackage{amssymb}
\usepackage{ascmac}
\usepackage{txfonts}
%\usepackage{graphics}
\input{poster_packages.tex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtheorem{df}{$\textrm{Definition}$}[subsubsection]
\newtheorem{ex}[df]{$\textrm{Example}$}
\newtheorem{prop}[df]{$\textrm{Proposition}$}
\newtheorem{lem}[df]{$\textrm{Lemmma}$}
\newtheorem{cor}[df]{$\textrm{Corollary}$}
\newtheorem{rmk}[df]{$\textrm{Remark}$}
\newtheorem{thm}[df]{$\textrm{Theorem}$}
\newtheorem{axi}[df]{$\textrm{Axiom}$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\bdf}{\begin{shadebox} \begin{df}}
\newcommand{\edf}{\end{df} \end{shadebox}}
\newcommand{\bex}{\begin{ex}}
\newcommand{\eex}{\end{ex}}
\newcommand{\bprop}{\begin{shadebox} \begin{prop}}
\newcommand{\eprop}{\end{prop} \end{shadebox}}
\newcommand{\blem}{\begin{shadebox} \begin{lem}}
\newcommand{\elem}{\end{lem} \end{shadebox}}
\newcommand{\bcor}{\begin{shadebox} \begin{cor}}
\newcommand{\ecor}{\end{cor} \end{shadebox}}
\newcommand{\brmk}{\begin{rmk}}
\newcommand{\ermk}{\end{rmk}}
\newcommand{\bthm}{\begin{shadebox} \begin{thm}}
\newcommand{\ethm}{\end{thm} \end{shadebox}}
\newcommand{\bpf}{\begin{proof}}
\newcommand{\epf}{\end{proof}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\D}{\mathbb{D}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\qcoe}[2]{\left[\begin{array}{ccc}#1\\#2\end{array}\right]}
\newcommand{\plim}{{\displaystyle \lim_{\substack{\longleftarrow\\ n}}}}
\newcommand{\seq}[2]{(#1_{#2})_{#2\ge1}}
\newcommand{\Zmod}[1]{\Z/p^{#1}\Z}
\newcommand{\Lra}{\Longrightarrow}
\newcommand{\Llra}{\Longleftrightarrow}
\newcommand{\lra}{\leftrightarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\ol}[1]{{\overline{#1}}}
\newcommand{\ul}[1]{{\underline{#1}}}
\newcommand{\sem}[1]{[\hspace{-2pt}[{#1}]\hspace{-2pt}]}
\newcommand{\pros}[1]{\begin{array}{c} \ast \ast\\ \tt{#1} \end{array}}
\newcommand{\pgm}[1]{{\tt{#1}}\text{-プログラム}}
\newcommand{\pgms}[1]{{\tt{#1}}\text{-プログラム集合}}
\newcommand{\dtm}[1]{{\tt{#1}}\text{-データ}}
\newcommand{\data}[1]{{\tt{#1}}\text{-データ集合}}
\newcommand{\rtf}[3]{time^{\tt{#1}}_{\tt{#2}}({\tt{#3}})}
\newcommand{\id}{\textrm{id}}
\newcommand{\refl}{\textrm{refl}}
\newcommand{\ap}{\textrm{ap}}
\newcommand{\apd}{\textrm{apd}}
\newcommand{\pr}[1]{\textrm{pr}_{#1}}
\newcommand{\tp}{\textrm{transport}}
\newcommand{\qinv}{\textrm{qinv}}
\newcommand{\iseq}{\textrm{isequiv}}
\newcommand{\peq}{\textrm{pair}^=}
\newcommand{\sig}[3]{\sum_{{#1} : {#2}} {#3}\ ({#1})}
\newcommand{\0}{\textbf{0}}
\newcommand{\1}{\textbf{1}}
\newcommand{\2}{\textbf{2}}
\newcommand{\fune}{\textrm{funext}}
\newcommand{\happ}{\textrm{happly}}
\newcommand{\ua}{\textrm{ua}}
\newcommand{\ide}{\textrm{idtoequiv}}
\newcommand{\set}[1]{\textrm{isSet({#1})}}
\newcommand{\lama}{\lambda \! \! \to}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\title{$q$-類似のCoqによる形式化}
\author{アドバイザー $\colon$ Jacques Garrigue教授\\
           学籍番号 $\colon$ 322101289\\
           氏名 $\colon$ 中村　薫}
\date{\today}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{序文}
本論文の主結果は, $q$-類似の初等的な結果をCoqによって形式化するものである. 具体的には{\it Quantum Calculus}\cite{Kac}の5章前半, (5.5)式
\begin{screen}
  \[
    (x + a)^n_q = \sum_{j = 0}^n \qcoe{n}{j} q^{j (j - 1)/2} a^j x^{n - j}
  \]
\end{screen}
(ここで,   $x$, $q \in \R$, $n \in \Z_{>0}$であり, $(x + a)^n_q$, $\qcoe{n}{j}$はそれぞれ$(x + a)^n_j$, 二項係数の$q$-類似である)の形式化までを扱う. 
本論文での$q$-類似に関する定義や定理, 証明は\cite{Kac}によるものだが, その形式化を行ったという点において独自性がある. \\
基本的には, \cite{Kac}での定義, 定理を述べた後, その形式化を与え, 必要であれば形式化をするにあたっての注意点を述べることを繰り返すという流れで構成していく. 
証明の方針等は基本的に\cite{Kac}の通りであるが, \ref{sssec q_Taylor}では一部\cite{Kac}から離れ, 多項式として$q$-微分や$q$-二公式を定義しなおして形式化を行っている. これらの新たな定義が多項式に対してのもとの定義を適用したものと一致していることの証明も行っている.  

\textbf{$q$-類似の概要}\\
$q$-類似とは, 実数パラメータ$q$を極限で$1$に近づけると通常の数学に一致するような一般化
のことである. 例えば自然数の$q$-類似は$1$, $1 + q$, $1 + q + q^2 \ldots$である. 
$e^x$, $\sin x$などの初等関数や積分の$q$-類似も考えられる　微分積分学の基本定理も成り立つ. ただしこれらは無限和が必要なので形式化はできていない. 
また, あえてパラメータを増やす$q$-類似を考える利点の一つとしては, 証明が複雑な定理に対してより簡単な別証明を与えられることである. 例えば, ヤコビの三重積(\cite{Kac} p35 Theorem 11.1)
\begin{screen}
$z$, $q \in \R$, $|q| < 1$として, 
\[
  \sum_{n = -\infty}^{\infty} q^{n^2} z^n =
  \prod_{n = 1}^{\infty} (1 - q^{2n})(1 + q^{2n - 1}z)(1 + q^{2n - 1}z^{-1})
\]
が成り立つ. 
\end{screen}
はその一例である. 楕円関数論の文脈で登場する恒等式であるが(\cite{Ume} p144 (3.47)等を参照), $q$-類似で得られる式
\begin{align*}
  (1 + x)^{\infty}_q &=
    \sum_{j = 0}^{\infty} q^{j(j - 1)/2} \frac{x^j}{(1 - q) (1 - q^2) \cdots (1 - q^j)}
     \quad(\text{\cite{Kac} p30 (9.3)式}) \\
  \frac{1}{(1 - x)^{\infty}_q} &=
    \sum_{j = 0}^{\infty} \frac{x^j}{(1 - q) (1 - q^2) \cdots (1 - q^j)}
      \quad(\text{\cite{Kac} p30 (9.4)式})
\end{align*}
を用いることで簡単に証明できる. 

\textbf{Coqの概要}\\
Coqとは, 定理証明支援系の1つであり, 数学的な証明が正しいかどうか判定するプログラムである.
人間がチェックすることが難しい複雑な証明でも正しさが保証され, また証明付きプログラミングにも応用される. 実際にCoqが用いられた有名な例として, 四色定理やフェイト・トンプソンの定理(奇数位数定理)などがある. Coqは型付き$\lambda$計算という理論に基づいている. 修士1年次に学習した\cite{Bar}に沿って, 型付き$\lambda$計算の概要について\ref{sssec lambdacal}で述べる. 
今回の証明に関しては, Coqの標準ライブラリ \cite{coq sl}に加えて, 数学の証明のために整備されたライブラリである mathcomp \cite{coq mc}も用いている. Coq や mathcompの使い方については\ref{ssec Coq}節で説明するが, より詳細な情報については\cite{Hag}等を参照のこと. 

%\textbf{今後の展望}\\

%研究に至った背景
%修士1年次後半で学習した型付き$\lambda$計算の応用としてCoqによる形式化に挑戦したい
%学部4年次の卒業研究で扱った$q$-類似がその題材に適していると考えた
%  特に初等的な部分に関しては代数的に操作でき, 極限操作に関する議論が必要ない
%  (-> 極限には開発中のライブラリである mathcomp analysis が必要
%  代数的な部分は mathcomp で足りる)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{本文}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Coq} \label{ssec Coq}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{$\lambda$計算} \label{sssec lambdacal}
まず型のない$\lambda$計算を定義する. 初めに, $\lambda$計算がどのようなものなのかについての概要を説明し, その後厳密な定義に移る. \\
\textbf{$\lambda$計算の概要}\\
$\lambda$計算には, 抽象と適用の2つの基本的な操作がある. まず, 抽象については, 「式から関数を作る操作」と捉えることができる. $M$を$\lambda$計算における式($\lambda$計算においてはこれを$\lambda$項と呼ぶ)だとすると, 
\[
  \lambda x . M
\]
で, 「$x$を変数とする関数」を表すことになる. 
例えば, $M$が$x^2 + 3xy + 4$という式であれば, 
\begin{itemize}
  \item $\lambda x . (x^2 + 3xy + 4)$
  \item $\lambda xy . (x^2 + 3xy + 4)$
  \item $\lambda z . (x^2 + 3xy + 4)$
\end{itemize}
はそれぞれ, 1つ目は$x \mapsto (x^2 + 3xy + 4)$という$x$についての2次関数, 
2つ目は$(x, y) \mapsto (x^2 + 3xy + 4)$という$x, y$についての2変数関数を表す. 
3つ目は, $(x^2 + 3xy + 4)$は変数$z$を含まないので, 定数関数を表すことになる. \\
もう1つの操作である適用は, 2つの$\lambda$項$M$と$N$を並べて, 
\[
  MN
\]
と書かれ, 直観的には「関数$M$に値$N$を代入する」ことを示している. 
例えば, $M$が$\lambda x . (3x + 2)$, $N$が$4$であれば, 
\[
  (\lambda x . (3x + 2))\ 4 = 3 \cdot 4 + 2\ (= 14)
\]
となる. 一般には, $[x \coloneqq N]$で$x$に$N$を代入することを表すとして, 
\[
  (\lambda x. M)\ N = M[x\coloneqq N]
\]
と書く. \\
\textbf{{$\lambda$計算の定義}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Coqの使い方}
%Coq とは, 定理証明支援系の1つであり, 数学的な証明が正しいかどうか判定するプログラムである. 人間がチェックすることが難しい複雑な証明でも正しさが保証され, また証明付きプログラミングにも応用される. 例えば, 
命題$P$, $Q$について, $P \Lra Q$かつ$P$であれば, $Q$が成り立つということは, Coq では
\begin{lstlisting}{Coq}
From mathcomp Require Import ssreflect.

Theorem modus_ponens (P Q : Prop) : (P -> Q) /\ P -> Q.
Proof.
  move=> [] pq p.
  by apply pq.
Qed.
\end{lstlisting}
と表現できる. \\
Coq による証明は, Curry-Howard 同型と呼ばれる, 
\begin{align*}
  \text{命題} &\leftrightarrow \text{型} \\
  \text{証明} &\leftrightarrow \text{型に要素が存在する}
\end{align*}
という対応関係に基づいている. また, 論理演算子についても, 以下のような対応がある. 
\begin{align*}
  P \text{ならば} Q &\quad P \rightarrow Q \\
  P \text{かつ} Q &\quad P \times Q \\
  P \text{または} Q &\quad  P + Q
\end{align*}
この同型をもとに上記の証明をもう一度考えてみると, $P \ra Q$と$P$という型に要素が存在することから, $Q$という型の要素を構成すればよいということである. \\
まず, 前提の要素それぞれに$pq$, $p$と名前をつける. これがプログラム中の{\tt move$\Rightarrow$ [] pq p}のことである. 
ここで, $P \to Q$という型は, 入力する値の型が$P$, 出力する値の型が$Q$であるような関数の型であるため, $P$の要素$p$に$pq$を適用することで, $Q$の要素を構成することができる. この関数適用がプログラム中の{\tt apply pq}のことである. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$q$-類似}
$q$-類似とは, $q \to 1$とすると通常の数学に一致するような拡張のことである. 例えば, 自然数$n$の$q$-類似$[n]$は
\[
  [n] = 1 + q + q^2 + \cdots q ^ {n -1} 
\]
であり, $(x-a)^n$の$q$-類似$(x-a)^n_q$は
\[
  (x-a)^n_q \coloneqq \begin{cases}
                                  1 & (n=0)\\
                                  (x-a)(x-qa)\cdots(x-q^{n-1}a) & (n\ge1)
                                \end{cases}
\]
である. 本論文では, この$(x - a)^n_q$に対して, 
\[
  (x+a)^n_q = \sum_{j=0}^n \qcoe{n}{j} q^{\frac{j(j-1)}{2}} a^j x^{n-j}
\]
が成り立つことの形式化を目標としている(ただし, $\qcoe{n}{j}$は二項係数の$q$-類似). また, 本論文では扱わないが, $q$-類似を考える利点の一つとして, 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{形式化}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{$q$-微分の定義}
様々な$q$-類似を考えるにあたって, まずは微分の$q$-類似から始める. 以下, $q$を$1$でない実数とする. 
\bdf[\cite{Kac} p1 (1.1), p2 (1.5)]
  関数$f : \R \to \R$に対して, $f(x)$の$q$差分$d_q f(x)$を, 
  \[
    d_q f(x) \coloneqq f (qx) - f(x)
  \]
  と定める. 更に, $f(x)$の$q$差分を$D_q f(x)$を, 
  \[
    D_q f(x) \coloneqq \frac{d_q f(x)}{d_q x} = \frac{f(qx) - f(x)}{(q - 1) x}
  \]
  と定める. 
\edf
この定義を形式化すると, 
\begin{lstlisting}{Coq}
From mathcomp Require Import all_ssreflect all_algebra.
Import GRing.

Section q_analogue.
Local Open Scope ring_scope.
Variable (R : rcfType) (q : R).
Hypothesis Hq : q - 1 != 0.

Notation "f // g" := (fun x => f x / g x) (at level 40).

Definition dq (f : R -> R) x := f (q * x) - f x.
Definition Dq f := dq f // dq id. 
\end{lstlisting}
となる. このコードの意味は大まかに以下のとおりである. 
\begin{itemize}
  \item 最初の2行で必要なライブラリの指定をしている. 
  \item {\tt Variable}でそのセクション内で共通して使う変数を宣言している. 
          {\tt R}がCoqにおける実数(正確には{\tt mathcomp}の{\tt algebra}の real closed field
          ：実閉体)の役割を果たす. ここではまだ出てきていないが, {\tt nat}が$0$を含む
          自然数に, {\tt int}が整数に対応する. 
  \item {\tt Hypothesis}で, $q$が1でないという仮定をしている. 使いやすさのため, 
          $q \ne 1$ではなく$q - 1 \ne 0$という形にしている. 
  \item {\tt Notation}で関数同士の割り算の記法を定義している. 
  \item 2つの{\tt Definition}で$q$-差分と$q$-微分をそれぞれ定義している. 
          {\tt $\coloneqq$}以前に定義の名前と引数, 以後に具体的な定義が書いてある. 
          例えば$q$-差分についてであれば, {\tt d\_q}が名前, {\tt f}と{\tt x}が引数, 
          {f (q * x) - f x}が定義である. ({\tt f}の後ろの{\tt : R $\to$ R}は{\tt f}の型である. 
          一方, もう一つの引数である{\tt x}には型を書いていない. これは, Coqには強力な
          型推論があるため, 推論できるものであれば型を書く必要がないためである. )
          $D_q$の定義の中の{\tt id}は恒等関数のことである. 
\end{itemize}
\brmk
  $f$が微分可能であるとき, 
  \[
    \lim_{q\ra1} D_qf(x) = \frac{d}{dx}f(x)
  \] 
  が成り立つが, 本稿においては極限操作に関しての形式化は扱わない. 
\ermk
次に, $x ^ n$ ($n \in \Z_{\ge 0}$)を$q$-微分した際にうまく振る舞うように自然数の$q$-類似を定義する. 
\bdf[\cite{Kac} p2 (1.9)]
  $n \in \Z_{\ge 0}$に対して, $n$の$q$-類似$[n]$を, 
  \[
    [n] \coloneqq \frac{q^n - 1}{q - 1}
  \]
  と定義する. 
\edf
この$[n]$に対して, $(x^n)' = n x^{n-1}$の$q$-類似が成り立つ.
\bprop[\cite{Kac} p2 Example (1.7)]
  $n \in \Z_{>0}$について, 
  \[
    D_q x^n = [n] x ^{n - 1}
  \]
  が成り立つ. 
\eprop
\bpf
  定義に従って計算すればよく, 
  \[
    D_q x ^ n = \frac{(qx) ^ n - x ^ n}{(q - 1) x}
                 = \frac{q^n - 1}{q - 1} x ^ {n - 1}
                 = [n] x ^ {n - 1}
  \] 
\epf
この定義と補題の形式化は以下のとおりである. 
\begin{lstlisting}{Coq}
Definition qnat n : R := (q ^ n - 1) / (q - 1).

Lemma Dq_pow n x :
  x != 0 -> Dq (fun x => x ^ n) x = qnat n * x ^ (n - 1).
Proof.
  move=> Hx.
  rewrite /Dq /dq /qnat.
  rewrite -{4}(mul1r x) -mulrBl expfzMl -add_div; last by apply mulf_neq0.
  rewrite [in x ^ n](_ : n = (n -1) +1) //; last by rewrite subrK.
  rewrite expfzDr ?expr1z ?mulrA -?mulNr ?red_frac_r ?add_div //.
  rewrite -{2}[x ^ (n - 1)]mul1r -mulrBl mulrC mulrA.
  by rewrite [in (q - 1)^-1 * (q ^ n - 1)] mulrC.
Qed.
\end{lstlisting}
ここでも, コードについて少し説明を加える. 
\begin{itemize}
  \item {\tt Definition}と同様, {\tt Lemma}について, {\tt $\coloneqq$}の前に補題の名前と
          引数が, 後に補題の主張が書いてある. 今回であれば, {\tt Dq\_of\_pow}が補題の
          名前で, {\tt n}と{\tt x}が引数である. 
  \item {\tt Proof.}以下が補題の証明である. 
  \item {\it def}が定義のとき, {\tt rewrite /{\it def}}で定義を展開している. 
  \item {\it lem}が{\tt A = B}という形の補題のとき, {\tt rewrite {\it lem}}で結論に出現する
          {\tt A}を{\tt B}に書き換えている. 他のコマンドの使い方については \cite{Hag}等を参照. 
  \item {\tt red\_frac\_r}は, 
           \begin{lstlisting}{Coq}
red_frac_r : forall x y z : R, z != 0 -> x * z / (y * z) = x / y \end{lstlisting}
           という補題である. この補題を使うため, もともとはなかった{\tt $x \ne 0$}という
           前提を加えている. 実際, $D_q$の定義において分母に$x$が出現するので, 
           $x$が$0$でないという前提は妥当である.  
\end{itemize}
\brmk
  {\tt qnat}という名前であるが, 実際には{\tt n}の型は{\tt nat}ではなく{\tt R}にしている. 
  また, {\tt Dq\_of\_pow}の{\tt n}の型は{\tt int}であるため, より一般化した形での形式化に
  なっている. 
\ermk
\cite{Kac}では証明は1行で終わっているが, 形式化する場合には何倍もかかっている. これは, 積の交換法則や指数法則などの, 通常の数学では「当たり前」なことが自動では計算されず, {\tt rewrite mulrC}や{\tt rewrite expfzDr}というように{\tt rewrite}での書き換えを明示的に行わなければならないからである. \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{$(x - a)^n$の$q$-類似}
続いて$(x - a)^n$の$q$-類似を定義し, その性質を調べる.  
\bdf[\cite{Kac} p8 Definition (3.4)]
  $x$, $a \in \R$, $n \in \Z_{\ge 0}$に対して, $(x - a)^n$の$q$-類似$(x - a)^n_q$を, 
  \[
  (x - a)^n_q = \begin{cases}
                      1 & \text{if}\ n = 0 \\
                      (x - a) (x - qa) \cdots (x - q^{n - 1} a) & \text{if}\ n \ge 1
                    \end{cases}
  \]
  と定義する. 
\edf
\bprop \label{Dq_qbinom_nonneg}
  $n\in\Z_{>0}$に対し, 
  \[
    D_q(x-a)^n_q = [n](x-a)^{n-1}_q
  \]
  が成り立つ. 
\eprop
\bpf
  $n$についての帰納法により示される. 
\epf
まず, $(x - a)^n_q$の定義を形式化すると, 
\begin{lstlisting}{Coq}
Fixpoint qbinom_pos a n x :=
  if n is m.+1 then (qbinom_pos a m x) * (x - q ^ m * a) else 1. \end{lstlisting}
となる. {\tt Fixpoint}を用いて再帰的な定義をしており, {\tt if then else}を使って{\tt n}が{\tt 0}かどうかで場合分けしている. 補題の証明については 
\begin{lstlisting}{Coq}
Theorem Dq_qbinom_pos a n x : x != 0 ->
  Dq (qbinom_pos a n.+1) x =
  qnat n.+1 * qbinom_pos a n x.
Proof.
  move=> Hx.
  elim: n => [|n IH].
  - rewrite /Dq /dq /qbinom_pos /qnat.
    rewrite !mul1r mulr1 expr1z.
    rewrite opprB subrKA !divff //.
    by rewrite denom_is_nonzero.
  - rewrite (_ : Dq (qbinom_pos a n.+2) x =
                 Dq ((qbinom_pos a n.+1) **
                 (fun x => (x - q ^ (n.+1) * a))) x) //.
    rewrite Dq_prod' //.
    rewrite [Dq (+%R^~ (- (q ^ n.+1 * a))) x]/Dq /dq.
    rewrite opprB subrKA divff //; last by apply denom_is_nonzero.
    rewrite mulr1 exprSz.
    rewrite -[q * q ^ n * a]mulrA -(mulrBr q) IH.
    rewrite -[q * (x - q ^ n * a) * (qnat n.+1 * qbinom_pos a n x)]mulrA.
    rewrite [(x - q ^ n * a) * (qnat n.+1 * qbinom_pos a n x)]mulrC.
    rewrite -[qnat n.+1 * qbinom_pos a n x * (x - q ^ n * a)]mulrA.
    rewrite (_ : qbinom_pos a n x * (x - q ^ n * a) = qbinom_pos a n.+1 x) //.
    rewrite mulrA -{1}(mul1r (qbinom_pos a n.+1 x)).
    by rewrite -mulrDl -qnat_cat1.
Qed.
\end{lstlisting}
となる. ここで{\tt elim:\,n}は{\tt n}の帰納法に対応している. \\
指数法則については, 一般には$(x - a)^{m + n} \neq (x - a)^m_q(x - a)^n_q$であり, 以下のようになる. 
\bprop[\cite{Kac} p8 (3.6)] \label{q_exp_low}
  $x,a\in\R$, $m,n\in\Z_{>0}$について, 
  \[
    (x-a)^{m+n}_q = (x-a)^m_q (x-q^ma)^n_q
  \]
  が成り立つ. 
\eprop
\bpf
  \begin{align*}
    (x-a)^{m+n}_q &= (x-a)(x-qa)\cdots(x-q^{m-1}a)
                         \times (x-q^ma)(x-q^{m+1}a)\cdots(x-q^{m+n-1})\\
                       &= (x-a)(x-qa)\cdots(x-q^{m-1}a)
                         \times (x-q^ma)(x-q(q^mx))\cdots(x-q^{n-1}(q^ma))\\
                       &= (x-a)^m_q(x-q^ma)^{n}_q
  \end{align*}
  より成立する.
\epf
この形式化は次のとおりである. 
\begin{lstlisting}{Coq}
Lemma qbinom_pos_explaw x a m n :
  qbinom_pos a (m + n) x =
    qbinom_pos a m x * qbinom_pos (q ^ m * a) n x.
Proof.
  elim: n.
  - by rewrite addn0 /= mulr1.
  - elim => [_|n _ IH].
    + by rewrite addnS /= addn0 expr0z !mul1r.
    + rewrite addnS [LHS]/= IH /= !mulrA.
      by rewrite -[q ^ n.+1 * q ^ m] expfz_n0addr // addnC.
Qed.
\end{lstlisting}
\cite{Kac}の証明では単に式変形しているが, {\tt qbinom\_nonneg}が再帰的に定義されているため, 形式化の証明では{\tt m}, {\tt n}に関する帰納法を用いている. \\
この指数法則を用いて, $(x - a)^n_q$の$n$を負の数に拡張する. まず, \cite{Kac}の定義は
\bdf[\cite{Kac} p9 (3.7)] \label{qbinom_neg}
  $x$, $a \in \R$, $l\in\Z_{>0}$とする. このとき, 
  \[
    (x-a)^{-l}_q \coloneqq \frac{1}{(x-q^{-l}a)^l_q}
  \]
  と定める. 
\edf
であり, この形式化は, 
\begin{lstlisting}{Coq}
Definition qbinom_neg a n x := 1 / qbinom_nonneg (q ^ ((Negz n) + 1) * a) n x.
\end{lstlisting}
となる. ここで, {\tt Negz n}とは{\tt Negz n = - n.+1}をみたすものであって, {\tt int}は
\begin{lstlisting}{Coq}
Variant int : Set := Posz : nat -> int | Negz : nat -> int.
\end{lstlisting}
のように定義されている. よって, {\tt int}は$0$以上か負かで場合分けできるため, {\tt n :\,int}に対して, 
\begin{lstlisting}{Coq}
Definition qbinom a n x :=
  match n with
  | Posz n0 => qbinom_pos a n0 x
  | Negz n0 => qbinom_neg a n0.+1 x
  end.
\end{lstlisting}
と定義できる. \\
整数に拡張した$(x - a)^n_q$についても, 指数法則とと$q$-微分はうまく振る舞う.
まず, 指数法則について,  
\bprop[\cite{Kac} p10 Proposition 3.2]
  $m$, $n \in \Z$について, Proposition \ref{q_exp_low}は成り立つ. 
\eprop
\bpf
  $m$, $n$の正負で場合分けして示す. $m > 0$かつ$n > 0$の場合はすでに示しており, 
  $m = n =0$の場合は定義からすぐにわかる. その他の場合について, まず$m < 0$かつ
  $n \ge 0$の場合, $m = -m'$とおくと
  \begin{align*}
    (x - a)^m_q (x - q^m)^n_q &= (x - a)^{-m'}_q (x - q^{-m'} a)^n_q\\
                                       &= \frac{(x - q^{-m'} a)^n_q}{(x - q^{-m'} a)^{m'}_q}\\
                                       &= \begin{cases}
                                              (x - q^{m'} (q ^{-m'} a))^{n - m'}_q & n \ge m' \\
                                              \frac{1}{(x - q^n (q ^{-m'} a))^{m' - n}_q} & n < m'
                                            \end{cases}\\
												 &= (x - a)^{n - m'}_q\\
												 &= (x - a)^{n + m}_q
  \end{align*}
  というように, $n$と$m'$の大小で場合分けすることで示せる. 次に, $m \ge 0$かつ$n < 0$
  の場合, $n = - n'$として, 
  \begin{align*}
    (x - a)^m_q (x - q^m)^n_q &= (x - a)^{m}_q (x - q^m a)^{-n'}_q\\
                                       &= \begin{cases}
                                             \frac{(x - a)^{m - n'}_q (x - q^{m - n'} a)^{n'}_q}
                                                    {(x - q^{m - n'} a)^{n'}_q} & m \ge n' \\
                                             \frac{(x - a)^m_q}
                                     {(x - q^{m - n'})^{n' - m}_q (x - q^{n' - m}(q^{m - n'}a))} & m < n      
                                           \end{cases}\\
                                       &= \begin{cases}
                                              (x - a)^{m - n'} & m \ge n' \\
                                              \frac{1}{(x - q^{m - n'})^{n' - m}_q} & m < n'
                                            \end{cases}\\
                                       &=  (x - a)^{m - n'}_q = (x - a)^{m + n}_q
  \end{align*}
  となる. 最後に, $m < 0$かつ$n < 0$のとき, $m = -m'$, $n = -n'$として, 
  \begin{align*}
    (x - a)^m_q (x - q^m)^n_q &= (x - a)^{-m'}_q (x - q^{-m'})^{-n'}_q\\
                                       &= \frac{1}{(x - q^{-m'} a)^{m'}_q (x - q^{-n'-m'}a)^{n'}_q}\\
                              &= \frac{1}{(x - q^{-n'-m'}a)^{n'}_q (x - q^{n'}(q^{-m'-n'} a))^{m'}_q }\\
                                       &= \frac{1}{(x - q^{-n'-m'} a)^{n' + m'}_q}\\
                                       &= (x - a)^{-m'-n'}_q\\
                                       &= (x - a)^{m' + n'}
  \end{align*}
  となる.
\epf
この補題を形式化すると, 
\begin{lstlisting}{Coq}
Theorem qbinom_explaw a m n x : q != 0 ->
  qbinom_denom a m x != 0 ->
  qbinom_denom (q ^ m * a) n x != 0 ->
  qbinom a (m + n) x = qbinom a m x * qbinom (q ^ m * a) n x.
Proof.
  move=> Hq0.
  case: m => m Hm.
  - case: n => n Hn.
    + by apply qbinom_pos_explaw.
    + rewrite qbinom_exp_pos_neg //.
      by rewrite addrC expfzDr // -mulrA.
  - case: n => n Hn.
    + by rewrite qbinom_exp_neg_pos.
    + by apply qbinom_exp_neg_neg.
Qed.
\end{lstlisting}
となる. 証明の構造としては, まず{\tt case:m}で{\tt m}が$0$以上か負かの場合分けを行い, 更にそれぞれの場合について{\tt case:n}で{\tt n}の場合分けを行っている. 
ここで, 前提の{\tt qbinom\_denom}の定義は
\begin{lstlisting}{Coq}
Definition qbinom_denom a n x :=
  if n is Negz m then qbinom_pos (q ^ Negz m * a) m.+1 x else 1. \end{lstlisting}
であり, 2つの前提は補題の右辺に出現する項の分母が$0$にならないということである. 
証明中に使われている補題のうち, {\tt qbinom\_exp\_pos\_neg}, {\tt qbinom\_exp\_neg\_pos}, {\tt qbinom\_exp\_neg\_neg}はそれぞれ$m \ge 0$かつ$n < 0$, $m <0$かつ$n \ge 0$, $m < 0$かつ$n < 0$のときの証明の形式化であり, 例えば{\tt qbinom\_exp\_pos\_neg}については
\begin{lstlisting}{Coq}
Lemma qbinom_exp_pos_neg a (m n : nat) x : q != 0 ->
  qbinom_pos (q ^ (Posz m + Negz n) * a) n.+1 x != 0 ->
  qbinom a (Posz m + Negz n) x = qbinom a m x * qbinom (q ^ m * a) (Negz n) x.
Proof.
  move=> Hq0 Hqbinommn.
  case Hmn : (Posz m + Negz n) => [l|l]  /=.
  - rewrite /qbinom_neg mul1r.
    rewrite (_ : qbinom_pos a m x = qbinom_pos a (l + n.+1) x).
      rewrite qbinom_pos_explaw.
      have -> : q ^ (Negz n.+1 + 1) * (q ^ m * a) = q ^ l * a.
        by rewrite mulrA -expfzDr // -addn1 Negz_addK addrC Hmn.
      rewrite -{2}(mul1r (qbinom_pos (q ^ l * a) n.+1 x)) red_frac_r.
        by rewrite divr1.
      by rewrite -Hmn.
    apply Negz_transp in Hmn.
    apply (eq_int_to_nat R) in Hmn.
    by rewrite Hmn.
  - rewrite /qbinom_neg.
    have Hmn' : n.+1 = (l.+1 + m)%N.
      move /Negz_transp /esym in Hmn.
      rewrite addrC in Hmn.
      move /Negz_transp /(eq_int_to_nat R) in Hmn.
      by rewrite addnC in Hmn.
    rewrite (_ : qbinom_pos (q ^ (Negz n.+1 + 1) * (q ^ m * a)) n.+1 x 
               = qbinom_pos (q ^ (Negz n.+1 + 1) * (q ^ m * a))
                              (l.+1 + m) x).
      rewrite qbinom_pos_explaw.
      have -> : q ^ (Negz n.+1 + 1) * (q ^ m * a) =
                q ^ (Negz l.+1 + 1) * a.
        by rewrite mulrA -expfzDr // !NegzS addrC Hmn.
      have -> : q ^ l.+1 * (q ^ (Negz l.+1 + 1) * a) = a.
        by rewrite mulrA -expfzDr // NegzS NegzK expr0z mul1r.
      rewrite mulrA.
      rewrite [qbinom_pos (q ^ (Negz l.+1 + 1) * a) l.+1 x *
               qbinom_pos a m x]mulrC.
      rewrite red_frac_l //.
      have -> : a = q ^ l.+1 * (q ^ (Posz m + Negz n) * a) => //.
        by rewrite mulrA -expfzDr // Hmn NegzK expr0z mul1r.
      apply qbinom_exp_non0r.
      rewrite -Hmn' //.
    by rewrite Hmn'.
Qed.
\end{lstlisting}
となっている. この証明についての注目点としては, 
\begin{itemize}
  \item \cite{Kac}では$m$と$n'$の大小で場合分けをしていたが, 形式化では, 
           \begin{lstlisting}{Coq}
  case Hmn : (Posz m + Negz n) => [l|l]  /=. \end{lstlisting}
           として, {\tt m $-$ n'}の値を{\tt l}とおき, {\tt l}が{\tt 0}以上かどうかで
           場合分けをしている
  \item Coqでは$A = B$という等式はどの型の上でのものなのかが区別されている. 
           {\tt eq\_int\_to\_nat}という補題は{\tt int}上の等式を{\tt nat}上の等式に写している. 
\end{itemize}
などが挙げられる. 
さらに, $q$-微分については, 
\bprop[\cite{Kac} p10 Proposition 3.3]
  $n \in \Z$について, 
  \[
    D_q x^n = [n] x ^{n - 1}
  \]
  が成り立つ. ただし, $n$が整数の場合にも, 自然数のときと同様, $[n]$の定義は
  \[
    \frac{q^n - 1}{q - 1}
  \]
  である. 
\eprop
\bpf
  $n > 0$のときは Proposition \ref{Dq_qbinom_nonneg} であり, $n = 0$のときは$[0] = 0$からすぐにわかる. 
  $n < 0$のときは, Definition \ref{qbinom_neg}と, 商の微分公式の$q$-類似版である
  \[
    D_q \left( \frac{f(x)}{g(x)} \right) = \frac{g(x) D_q f(x) - f(x) D_q g(x)}{g(x) g(qx)} \quad
    \text{(\cite{Kac} p3 (1.13))}
  \]
  及び Proposition \ref{Dq_qbinom_nonneg}を用いて示される. 
\epf
\cite{Kac}と同じ方針で証明する. まず, $n = 0$のとき, 
\begin{lstlisting}{Coq}
Lemma Dq_qbinomn0 a x :
  Dq (qbinom a 0) x = qnat 0 * qbinom a (- 1) x.
Proof. by rewrite Dq_const qnat0 mul0r. Qed.
\end{lstlisting}
である. ここで, {\tt Dq\_const}は
\begin{lstlisting}{Coq}
Lemma Dq_const x c : Dq (fun x => c) x = 0.
Proof. by rewrite /Dq /dq addrK' mul0r. Qed.
\end{lstlisting}
という定数関数の$q$-微分は$0$であるという補題である. 次に, $n < 0$のときは
\begin{lstlisting}{Coq}
Theorem Dq_qbinom_neg a n x : q != 0 -> x != 0 ->
  (x - q ^ (Negz n) * a) != 0 ->
  qbinom_pos (q ^ (Negz n + 1) * a) n x != 0 ->
  Dq (qbinom_neg a n) x = qnat (Negz n + 1) * qbinom_neg a (n.+1) x.
Proof.
  move=> Hq0 Hx Hqn Hqbinom.
  destruct n.
  - by rewrite /Dq /dq /qbinom_neg /= addrK' qnat0 !mul0r.
  - rewrite Dq_quot //.
      rewrite Dq_const mulr0 mul1r sub0r.
      rewrite Dq_qbinom_pos // qbinom_qx // -mulNr.
      rewrite [qbinom_pos (q ^ (Negz n.+1 + 1) * a) n.+1 x *
                (q ^ n.+1 * qbinom_pos (q ^ (Negz n.+1 + 1 - 1) *
                  a) n.+1 x)] mulrC.
      rewrite -mulf_div.
      have -> : qbinom_pos (q ^ (Negz n.+1 + 1) * a) n x /
                    qbinom_pos (q ^ (Negz n.+1 + 1) * a) n.+1 x =
                      1 / (x - q ^ (- 1) * a).
        rewrite -(mulr1 (qbinom_pos (q ^ (Negz n.+1 + 1) * a) n x)) /=.
        rewrite red_frac_l.
          rewrite NegzE mulrA -expfzDr // addrA -addn2.
          rewrite (_ : Posz (n + 2)%N = Posz n + 2) //.
          by rewrite -{1}(add0r (Posz n)) addrKA.
        by rewrite /=; apply mulnon0 in Hqbinom.
      rewrite mulf_div.
      rewrite -[q ^ n.+1 *
                 qbinom_pos (q ^ (Negz n.+1 + 1 - 1) * a) n.+1 x *
                   (x - q ^ (-1) * a)]mulrA.
      have -> : qbinom_pos (q ^ (Negz n.+1 + 1 - 1) * a) n.+1 x *
                (x - q ^ (-1) * a) =
                qbinom_pos (q ^ (Negz (n.+1)) * a) n.+2 x => /=.
        have -> : Negz n.+1 + 1 - 1 = Negz n.+1.
          by rewrite addrK.
        have -> : q ^ n.+1 * (q ^ Negz n.+1 * a) = q ^ (-1) * a => //.
        rewrite mulrA -expfzDr // NegzE.
        have -> : Posz n.+1 - Posz n.+2 = - 1 => //.
        rewrite -addn1 -[(n + 1).+1]addn1.
        rewrite (_ : Posz (n + 1)%N = Posz n + 1) //.
        rewrite (_ : Posz (n + 1 + 1)%N = Posz n + 1 + 1) //.
        rewrite -(add0r (Posz n + 1)).
        by rewrite addrKA.
      rewrite /qbinom_neg /=.
      rewrite (_ : Negz n.+2 + 1 = Negz n.+1) // -mulf_div.
      congr (_ * _).
      rewrite NegzE mulrC /qnat -mulNr mulrA.
      congr (_ / _).
      rewrite opprB mulrBr mulr1 mulrC divff; last by rewrite expnon0.
      rewrite invr_expz (_ : - Posz n.+2 + 1 = - Posz n.+1) //.
      rewrite -addn1 (_ : Posz (n.+1 + 1)%N = Posz n.+1 + 1) //.
      by rewrite addrC [Posz n.+1 + 1]addrC -{1}(add0r 1) addrKA sub0r.
    rewrite qbinom_qx // mulf_neq0 //.
      by rewrite expnon0.
    rewrite qbinom_pos_head mulf_neq0 //.
    rewrite (_ : Negz n.+1 + 1 - 1 = Negz n.+1) //.
      by rewrite addrK.
    move: Hqbinom => /=.
    move/mulnon0.
    by rewrite addrK mulrA -{2}(expr1z q) -expfzDr.
Qed.\end{lstlisting}
と, 非常に長くなっているが積の交換則や結合則などが多く, {\tt Dq\_quot}が商の$q$-微分公式の形式化であるため, \cite{Kac}の証明をそのまま形式化したものになっている.  また, いくつかの項が$0$でないという条件がついているが, これらの項は Definition \ref{qbinom_neg} において分母に現れるため, {\tt Dq\_of\_pow}のときと同様妥当であると考えられる. これらをまとめて, 
\begin{lstlisting}{Coq}
Theorem Dq_qbinom a n x : q != 0 -> x != 0 ->
  x - q ^ (n - 1) * a != 0 ->
  qbinom (q ^ n * a) (- n) x != 0 ->
  Dq (qbinom a n) x = qnat n * qbinom a (n - 1) x.
Proof.
  move=> Hq0 Hx Hxqa Hqbinom.
  case: n Hxqa Hqbinom => [|/=] n Hxqa Hqbinom.
  - destruct n.
    + by rewrite Dq_qbinomn0.
    + rewrite Dq_qbinom_pos //.
      rewrite (_ : Posz n.+1 - 1 = n) // -addn1.
      by rewrite (_ : Posz (n + 1)%N = Posz n + 1) ?addrK.
  - rewrite Dq_qbinom_int_to_neg Dq_qbinom_neg //.
        rewrite Negz_addK.
        rewrite (_ : (n + 1).+1 = (n + 0).+2) //.
        by rewrite addn0 addn1.
      rewrite (_ : Negz (n + 1) = Negz n - 1) //.
      by apply itransposition; rewrite Negz_addK.
    by rewrite Negz_addK addn1.
Qed.
\end{lstlisting}
と形式化できる. {\tt case:\,n}で{\tt n}が$0$以上か負かで場合分けを行い, {\tt destruct n}で$0$か$1$以上かの場合分けをしており, それぞれの場合で{\tt Dq\_qbinom\_0}, {\tt Dq\_qbinom\_nonneg}, {\tt Dq\_qbinom\_neg}を使っていることが見て取れる. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{$q$-Taylor展開} \label{sssec q_Taylor}
この節では, 有限次Taylor展開の$q$-類似が成り立つこと, そしてその系として本論文の目的である Gauss's binomial formula が成り立つことを示し, 形式化する. 
まず, 一般に以下のことが成り立つことを確認しておく. 
\bthm[\cite{Kac} p5 Theorem 2.1] \label{general_Taylor}
$\K\coloneqq\R$または$\C$, $V\coloneqq\K[x]$とし, $D$を$V$上の線型作用素とする. また, 
$\{P_n(x)\}_{n=0}\subset V$ ($n=0,1,2,\cdots$)は次の三条件をみたすとする. 
  \begin{align*}
    &\textrm{(i)}\,P_0 = 1,\,P_n(a)=0 \quad ({}^{\forall}n\ge1)\\
    &\textrm{(ii)}\,\deg P_n = n \quad ({}^{\forall}n\ge0)\\
    &\textrm{(iii)}\,DP_n(x) = P_{n-1}(x) \quad ({}^{\forall}n\ge1), \quad D(1) = 0
  \end{align*}
ただし, $a\in\K$である. このとき, 任意の多項式$f(x)\in V$に対し, $\deg f(x)=N$とすると, 
  \[
    f(x) = \sum_{n=0}^N(D^nf)(a)P_n(x)
  \]
が成り立つ. 
\ethm
%\bpf
%  条件(ii)から$\{P_0(x), P_1(x), \ldots , P_n(x)\}$が$V$の基底であるため, 係数列$c_k$
%  が一意にとれて, 
%  \[
%    f(x) = \sum_{k = 0}^N c_k P_k(x)
%  \]
%  と表せる. このとき, 条件(i)から, $x = a$とすることで$c_0 = f(a)$が得られる. 更に, 条件(ii), (iii)と
%  $D$の線形性から, 両辺に$n$回($1 \le n \le N$)$D$を作用させることで, 
%  \[
%    (D^n f)(x) = \sum_{k = n}^N c_k D^n P_k (x) = \sum_{k = n}^N c_k P_{k - n}(x)
%  \]
%  となる. ここで$x = a$とすることで	条件(i)から
%  \[
%    c_n = (D^n f)(a) \quad (0 \le n \le N)
%  \]
%  が得られる. 
%\epf
この定理を形式化すると以下のようになる. 
\begin{lstlisting}{Coq}
Theorem general_Taylor D n P (f : {poly R}) a :
  islinear D -> isfderiv D P ->
  (P 0%N).[a] = 1 ->
  (forall n, (P n.+1).[a] = 0) ->
  (forall m, size (P m) = m.+1) ->
  size f = n.+1 ->
  f = \sum_(0 <= i < n.+1)
          ((D \^ i) f).[a] *: P i. \end{lstlisting}
記号の意味などは以下の通りである. 
\begin{itemize}
  \item {\tt \{poly R\}}は{\tt R}係数多項式を表す型であり, {\tt p : {poly R}, a : R}に対して
  {\tt p.[a]}で多項式{\tt p}の{\tt a}での値を, {\tt a *: p}でスカラー倍を表す. また, {\tt size p}は
  {\tt p}の次数$+ 1$で定義されている. 
  \item {\tt islinear}, {\tt isfderiv}はそれぞれ
    \begin{lstlisting}{Coq}
Definition islinear (D : {poly R} -> {poly R}) :=
  forall a b f g, D ((a *: f) + (b *: g)) = a *: D f + b *: D g.

Definition isfderiv D (P : nat -> {poly R}) := forall n,
  if n is m.+1 then (D (P m.+1)) = P m else (D (P n)) = 0. \end{lstlisting}
    という定義であり, 前者が線形作用素であること, 後者は条件(iii)を形式化したものである. 
  \item \cite{Kac}での証明には, $\{P_0(x), P_1(x), \ldots , P_n(x)\}$が$V$の基底
    となることを用いている. これを以下のように形式化した. 
    \begin{lstlisting}{Coq}
Lemma poly_basis n (P : nat -> {poly R}) (f : {poly R}) :
  (forall m, size (P m) = m.+1) ->
  (size f <= n.+1)%N ->
  exists (c : nat -> R), f = \sum_(0 <= i < n.+1) c i *: P i. \end{lstlisting}
    実際には生成系であることを示している. 
\end{itemize}
この定理において, 
\[
  D \equiv D_q, \quad P_n \equiv \frac{(x-a)^n_q}{[n]!}
\]
(ただし, $n\in\Z_{\ge0}$に対し, $[n]!$を
\[
    [n]! \coloneqq \begin{cases}
                          1 & (n=0)\\
                          [n]\times[n-1]\times\cdots\times[1] & (n\ge1)
                        \end{cases}
\]
と定める)とすることで, 有限次Taylor展開の$q$-類似が得られる. 
\bthm[\cite{Kac} p12 Theorem 4.1] \label{q_Taylor}
$f(x)$を, $N$次の実数係数多項式とする. 任意の$c\in\R$に対し, 
  \[
    f(x) = \sum_{j=0}^N (D_q^jf)(c)\frac{(x-c)^j_q}{[j]!}
  \]
が成り立つ. 
\ethm
\bpf
$\frac{(x-a)^n_q}{[n]!}$が, $a$, $D_q$に対してTheorem \ref{general_Taylor}の三条件をみたすことを確かめればよい. (i), (ii)は$(x-a)^n_q$の定義から, (iii)はProposition\ref{Dq_qbinom_nonneg}から分かる. 
\epf
この定理を形式化したいが, 型が合わないという問題が発生する. 実際, {\tt general\_Taylor}の型を調べてみると, 
\begin{lstlisting}{Coq}
general_Taylor
     : forall (D : {poly R} -> {poly R}) (n : nat) (P : nat -> {poly R}) (f : {poly R}) (a : R), ...\end{lstlisting}
となっているが, ${\tt D}_{\tt q}$, {\tt q\_binom}の型は
\begin{lstlisting}{Coq}
Dq : (R -> R) -> R -> R

qbinom_pos : R -> nat -> R -> R \end{lstlisting}
であり, 型が合わず代入できない. そこで, この問題を回避するため, 多項式に対しての$q$-微分と
多項式としての$(x - a)^n_q$を改めて定義する. まず, $q$-微分について, 
\begin{lstlisting}{Coq}
Definition scale_var (p : {poly R}):= \poly_(i < size p) (q ^ i * p`_i).
Definition dqp p := scale_var p - p.
Definition Dqp p := dqp p %/ dqp 'X.
\end{lstlisting}
と定義する. 
\begin{itemize}
  \item {\tt p`\_i}は多項式{\tt p}の{\tt i}次の係数を表すため, {\tt scale\_var}は多項式{\tt p}
    を受け取り, $i$次の係数を$q^i$倍した多項式を返す操作である.
  \item もとの$d_q$の定義は$f(qx) - f(x)$であるが, 多項式を入力して多項式を返す型で定義
    したいため, 値を入力することができないので, この形で定義した. 多項式に対しては$d_q$と同じ
    結果になることが確認できる(正確には, {\tt dqp}を適用した多項式での{\tt x}での値と, 
    ${\tt x} \mapsto {\tt p.[x]}$という関数に${\tt d}_{\tt q}$を適用した関数の{\tt x}での値が
    等しいということである). 
    \begin{lstlisting}{Coq}
Definition polyderiv (D : (R -> R) -> (R -> R)) (p : {poly R}) :=
  D (fun (x : R) => p.[x]).
Notation "D # p" := (polyderiv D p) (at level 49).
Lemma dqp_dqE p x : (dqp p).[x] = (dq # p) x.
    \end{lstlisting}
  \item {\tt Dqp}の定義について, {\tt p \%/ p'}は多項式{\tt p}を多項式{\tt p'}で割った商を
    表しており, {\tt 'X}は$x$のみからなる単項式である. 実際に多項式に対して{\tt Dqp}を計算
    すると, {\tt dqp}の定義から, {\tt dqp p}は定数項が打ち消しあい, また{\tt dqp 'X}は
    {\tt (q - 1) * 'X}となるので割り切れるはずである. 実際, 
    \begin{lstlisting}{Coq}
Lemma Dqp_ok p : dqp 'X %| dqp p.
    \end{lstlisting}
    が示せる({\tt p' \%| p}で{\tt p}が{\tt p'}で割り切れることを表す). 
\end{itemize}
今後は扱いやすさのため, {\tt `X}で約分した形
\begin{lstlisting}{Coq}
Definition Dqp' (p : {poly R}) := \poly_(i < size p) (qnat (i.+1) * p`_i.+1).
\end{lstlisting}
を用いる. このとき, {\tt Dqp}と{\tt Dqp'}が等しいことも示せる. 
\begin{lstlisting}{Coq}
Lemma Dqp_Dqp'E p : Dqp p = Dqp' p.
\end{lstlisting}
\brmk
この{\tt Lemma}で注意すべき点は, {\tt 'X \%/ 'X = 1\%:P}という計算をする際に特に条件が必要ないことである. Coqで約分の計算を行う際には分母が$0$でないという条件が必要だが, {\tt 'X}は単項式であるため, ゼロ多項式とは異なる. よって自動的に条件がみたされることになる. 
一方, {\tt Dqp}と{\tt Dq}が等しいことを示そうとすると, 
\begin{lstlisting}{Coq}
Lemma Dqp'_DqE p x : x != 0 -> (Dqp' p).[x] = (Dq # p) x.
\end{lstlisting}
というように$x \neq 0$という条件が必要になる. これは多項式の割り算ではなく実数の値の割り算での約分を計算する必要があるからである.
\ermk
次に, $(x - a)^n_q$を多項式として以下のように定義しなおす. 
\begin{lstlisting}{Coq}
Fixpoint qbinom_pos_poly a n :=
  if n is m.+1 then (qbinom_pos_poly a m) * ('X - (q ^ m * a)%:P) else 1.
\end{lstlisting}
この多項式の{\tt x}での値は元の定義の{\tt qbinom\_pos}と等しくなる. 
\begin{lstlisting}{Coq}
Lemma qbinom_posE a n x :
  qbinom_pos a n x = (qbinom_pos_poly a n).[x].
\end{lstlisting}
この{\tt Dqp}と{\tt qbinom\_pos\_poly}に対してもProposition \ref{Dq_qbinom_nonneg}と同じことが成り立つ. 
\begin{lstlisting}{Coq}
Lemma Dqp'_qbinom_poly a n :
  Dqp' (qbinom_pos_poly a n.+1) = (qnat n.+1) *: (qbinom_pos_poly a n).
\end{lstlisting}
\brmk
  基本的な証明の方針は\cite{Kac}と同じだが, {\tt Dq\_prod'}に対応する補題の証明のため, 
  {\tt scale\_var}が積について分解できること, つまり
  \begin{lstlisting}{Coq}
Lemma scale_var_prod (p p' : {poly R}) : scale_var (p * p') = scale_var p * scale_var p'. \end{lstlisting}
  を示しているが, 証明は
  \begin{lstlisting}{Coq}
Proof.
  pose n := size p.
  have : (size p <= n)%N by [].
  clearbody n.
  have Hp0 : forall (p : {poly R}), size p = 0%N ->
    scale_var (p * p') = scale_var p * scale_var p'.
    move=> p0 /eqP.
    rewrite size_poly_eq0.
    move/eqP ->.
    by rewrite mul0r scale_varC mul0r.
  elim: n p => [|n IH] p Hsize.
  ...
  Qed. \end{lstlisting}
  というように, 多項式の{\tt size}に関する帰納法を使いたいため, {\tt (size p <= n)\%N}
  という仮定を加えている. 
\ermk
これで準備が整ったため, Theorem \ref{q_Taylor}を形式化する. 
\begin{lstlisting}{Coq}
Fixpoint qfact n :=
  if n is m.+1 then qfact m * qnat m.+1 else 1.

Theorem q_Taylorp n (f : {poly R}) c :
  (forall n, qfact n != 0) ->
  size f = n.+1 ->
  f = \sum_(0 <= i < n.+1) ((Dqp' \^ i) f).[c] *: (qbinom_pos_poly c i / (qfact i)%:P).
\end{lstlisting}
{\tt Dqp}, {\tt qbinom\_pos\_poly}をもとの定義に戻したものについては, 
\begin{lstlisting}{Coq}
Theorem q_Taylor n (f : {poly R}) x c :
  q != 0 ->
  c != 0 ->
  (forall n, qfact n != 0) ->
  size f = n.+1 ->
  f.[x] =  \sum_(0 <= i < n.+1)
             ((Dq \^ i) # f) c * qbinom_pos c i x / qfact i.
\end{lstlisting}
というように形式化できる. 
\brmk
  $c \neq 0$という条件は約分のためのものであるが, $q \neq 0$はなぜ必要なのであろうか. 
  これは, 高階{\tt Dqp'}と{\tt Dq}を一致させる補題
  \begin{lstlisting}{Coq}
Lemma hoDqp'_DqE p x n : q != 0 -> x != 0 ->
  ((Dqp' \^ n) p).[x] = ((Dq \^ n) # p) x.
Proof.
  move=> Hq0 Hx.
  rewrite /(_ # _).
  elim: n x Hx => [|n IH] x Hx //=.
  rewrite Dqp'_DqE // {2}/Dq /dq -!IH //.
  by apply mulf_neq0 => //.
Qed. \end{lstlisting}
  の証明において, {\tt IH}を使う際に$q \ast x \neq 0$という条件が必要だからである. 
  さらに, 高階{\tt Dq}が定義できないという点からも$q \neq 0$という条件は妥当である.
  実際, $q = 0$のとき, 
  \begin{align*}
    (D_q ^2 f) (x) = (D_0 ^2 f) (x) &= (D_0 (D_0 f)) (x) \\
                      &= D_0 \left( \lambda x.\ \frac{f (0 x) - f(x)}{(0 - 1)x} \right) (x) \\
                      &= D_0 \left( \lambda x.\ \frac{f(x) - f(0)}{x} \right) (x) \\
                      &= (D_0 F) (x)
                        \quad (\text{ここで}F \coloneqq \lambda x.\ \frac{f(x) - f(0)}{x}
                                  \text{とおいた})\\
                      &= \lambda x.\ \frac{F(x) - F(0)}{x} (x) \\
                      &= \frac{F(x) - F(0)}{x}
  \end{align*}
  となるが, 
  \[
    F(0) = \frac{f(0) - f(0)}{0} = \frac{0}{0}
  \]
  となってしまう
  (Coq では{\tt 0 / 0}は{\tt 0}と計算されるが, これでも正しい計算結果とはならない).
  この問題が起きるのは{\tt dq}を値の代入を用いて定義しているからであり, 多項式
  係数を変化させることで定義している{\tt dqp}では{\tt q = 0}でも問題が起きない. 
  よってこの{\tt dqp}を用いている{\tt Dqp}および{\tt Dqp'}については{\tt q = 0}かどうかに
  かかわらず高階の操作を定義できる. 
\ermk
本論文の最後に, $x ^ n$と$(x - a)^n_q$にこのTaylor展開の$q$-類似を適用する. 
\blem[\cite{Kac} p12 Example (4.4)]
  $n \in \Z_{>0}$について, 
  \[
    x ^ n = \sum_{j = 0}^n \qcoe{n}{j} (x - 1)^j_q \quad
      \left( \text{ここで, }\qcoe{n}{j} \coloneqq \frac{[n]!}{[j]![n - j]!} \right)
  \]
  が成り立つ. 
\elem
\bpf
  Theorem \ref{q_Taylor}において, $f(x) = x^n$, $c = 1$とする. 
  任意の正整数$j <= n$に対して, $D_q x^n = [n] x ^{n -1}$より, 
  \[
    (D_q^j f) (x) = [n] [n - 1] \cdots [n - j +1] x^{n - j}
  \]
  となるので, 
  \[
    (D_q^j f)(1) = [n] [n - 1] \cdots [n - j +1]
  \]
  が得られる.   
\epf
\blem[\cite{Kac} p15 Example (5.5)]
  $n \in \Z_{>0}$について, 
  \[
    (x + a)^n_q = \sum_{j = 0}^n \qcoe{n}{j} q^{j (j - 1)/2} a^j x^{n - j}
  \]
  が成り立つ. この式は Gauss's binomial formula と呼ばれる. 
\elem
\bpf
  $f = (x + a)^n_q$とすると, 任意の正整数$j <= n$に対して, 
  \[
    (D_q ^j f) (x) = [n] [n - 1] [n - j + 1] (x + a)^{n - j}_q
  \]
  であり, また
  \[
    (x + a)^m_q = (x + a) (x + qa) \cdots (x + q^{m - 1} a)
  \]
  から, $(0 + a)^m_q = a \cdot qa \cdots q^{m - 1}a = q^{m (m - 1)/2}a^m$となるので, 
  \[
    (D_q^j f) (0) = [n] [n - 1] \cdots [n - j +1]q^{(n - j) (n - j - 1)/2} a^{n - j}
  \]
  が成り立つ. よって, Theorem \ref{q_Taylor} において, $f = (x + a)^n_q$, $c = 0$として, 
  \[
    (x + a)^n_q = \sum_{j = 0}^n \qcoe{n}{j} q^{(n - j) (n - j - 1)/2} a^{n - j} x^j
  \]
  が得られる. この式の右辺において$j$を$n - j$に置き換えることで, 
  \[
    \qcoe{n}{n - j} = \frac{[n]!}{[n - j]![n - (n - j)]!} = \frac{[n]!}{[j]![n - j]!} = \qcoe{n}{j}
  \]
  に注意すれば, 
  \[
    (x - a)^n_q = \sum_{j = 0}^n \qcoe{n}{j} q^{j (j - 1)/2} a^j x^{n - j}
  \]
  が成り立つ. 
\epf
この二つの等式の形式化はそれぞれ
\begin{lstlisting}{Coq}
Lemma q_Taylorp_pow n : (forall n, qfact n != 0) ->
  'X^n = \sum_(0 <= i < n.+1) (qbicoef n i *: qbinom_pos_poly 1 i).

Definition qbicoef n j := qfact n / (qfact j * qfact (n - j)).
Theorem Gauss_binomial' a n : (forall n, qfact n != 0) ->
  qbinom_pos_poly (-a) n =
  \sum_(0 <= i < n.+1) (qbicoef n i * q ^+ ((n - i) * (n - i - 1))./2 * a ^+ (n - i)) *: 'X^i.
Theorem Gauss_binomial a n : (forall n, qfact n != 0) ->
  qbinom_pos_poly (-a) n =
  \sum_(0 <= i < n.+1) (qbicoef n i * q ^+ (i * (i - 1))./2 * a ^+ i) *: 'X^(n - i). \end{lstlisting}
となる. 
\brmk
{\tt Gauss\_binomial'}の証明は
\begin{lstlisting}{Coq}
Proof.
  move=> Hfact.
  rewrite (q_Taylorp n (qbinom_pos_poly (-a) n) 0) //; last by rewrite qbinom_size.
  under eq_big_nat => i /andP [_ Hi].
    rewrite hoDqp'_qbinom0 //.
    rewrite [(qbinom_pos_poly 0 i / (qfact i)%:P)]mulrC.
    rewrite polyCV.
    rewrite scalerAl scale_constpoly.
    have -> : qbicoef n i * qfact i * q ^+ ((n - i) * (n - i - 1))./2 *
              a ^+ (n - i) / qfact i =
              qbicoef n i * q ^+ ((n - i) * (n - i - 1))./2 * a ^+ (n - i).
      rewrite -!mulrA; f_equal; f_equal.
      rewrite mulrC -mulrA; f_equal.
      by rewrite denomK.
    rewrite mul_polyC qbinom_x0.
  over.
  done.
Qed. \end{lstlisting}
となっており, {\tt q\_Taylor}ではなく{\tt q\_Taylorp}において{\tt c = 0}として証明している. 
{\tt q\_Taylor}には$c \neq 0$という前提があるため, この証明には使えない. 
\ermk
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{9}
  \bibitem{Kac} Victor Kac, Pokman Cheung, {\it{Quantum Calculus}}, Springer, 2001.
%  \bibitem{Gar} \url{https://www.math.nagoya-u.ac.jp/~garrigue/lecture/2021_AW/                  
%                           ssrcoq2.pdf}
  \bibitem{Hag} 萩原 学/アフェルト・レナルド, {\it Coq/SSReflect/Mathcomp}, 森北出版, 
    2018
  \bibitem{coq sl} \url{https://coq.inria.fr/distrib/current/stdlib/}
  \bibitem{coq mc} \url{https://github.com/math-comp/math-comp}
  \bibitem{Ume} 梅村 浩, 『楕円関数論  楕円曲線の解析学』, 東京大学出版会, 2000.
  \bibitem{Bar} H.P.Barendregt, {\it{Lambda Calculi with Types}}
\end{thebibliography}
\end{document}
