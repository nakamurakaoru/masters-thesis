\documentclass[11pt]{jsreport}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[a4paper,margin=25mm]{geometry}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{ascmac}
\newtheoremstyle{mystyle}% % Name
    {}%                      % Space above
    {}%                      % Space below
    {\normalfont}%           % Body font
    {}%                      % Indent amount
    {\bfseries}%             % Theorem head font
    {}%                      % Punctuation after theorem head
    { }%                     % Space after theorem head, ' ', or \newline
    {}%                      % Theorem head spec (can be left empty, meaning `normal')
\theoremstyle{mystyle}
\usepackage{amssymb}
\usepackage{ascmac}
\usepackage{txfonts}
\usepackage[all]{xy}
%\usepackage{graphics}
\input{poster_packages.tex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtheorem{df}{$\textrm{Definition}$}[section]
\newtheorem{ex}[df]{$\textrm{Example}$}
\newtheorem{prop}[df]{$\textrm{Proposition}$}
\newtheorem{lem}[df]{$\textrm{Lemma}$}
\newtheorem{cor}[df]{$\textrm{Corollary}$}
\newtheorem{rmk}[df]{$\textrm{Remark}$}
\newtheorem{thm}[df]{$\textrm{Theorem}$}
\newtheorem{axi}[df]{$\textrm{Axiom}$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% theorems %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\bdf}{\begin{shadebox} \begin{df}}
\newcommand{\edf}{\end{df} \end{shadebox}}
\newcommand{\bex}{\begin{ex}}
\newcommand{\eex}{\end{ex}}
\newcommand{\bprop}{\begin{shadebox} \begin{prop}}
\newcommand{\eprop}{\end{prop} \end{shadebox}}
\newcommand{\blem}{\begin{shadebox} \begin{lem}}
\newcommand{\elem}{\end{lem} \end{shadebox}}
\newcommand{\bcor}{\begin{shadebox} \begin{cor}}
\newcommand{\ecor}{\end{cor} \end{shadebox}}
\newcommand{\brmk}{\begin{rmk}}
\newcommand{\ermk}{\end{rmk}}
\newcommand{\bthm}{\begin{shadebox} \begin{thm}}
\newcommand{\ethm}{\end{thm} \end{shadebox}}
\newcommand{\baxi}{\begin{shadebox} \begin{axi}}
\newcommand{\eaxi}{\end{axi} \end{shadebox}}
\newcommand{\bpf}{\begin{proof}}
\newcommand{\epf}{\end{proof}}
%% always %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Lra}{\Longrightarrow}
\newcommand{\Llra}{\Longleftrightarrow}
\newcommand{\lra}{\leftrightarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\ol}[1]{{\overline{#1}}}
\newcommand{\ul}[1]{{\underline{#1}}}
%% sets %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\D}{\mathbb{D}}
%% q-analogue %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\qcoe}[2]{\left[\begin{array}{ccc}#1\\#2\end{array}\right]}
%% algebra %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\plim}{{\displaystyle \lim_{\substack{\longleftarrow\\ n}}}}
\newcommand{\seq}[2]{(#1_{#2})_{#2\ge1}}
\newcommand{\Zmod}[1]{\Z/p^{#1}\Z}
\newcommand{\sem}[1]{[\hspace{-2pt}[{#1}]\hspace{-2pt}]}
\newcommand{\pros}[1]{\begin{array}{c} \ast \ast\\ \tt{#1} \end{array}}
%% Jones %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\pgm}[1]{{\tt{#1}}\text{-プログラム}}
\newcommand{\pgms}[1]{{\tt{#1}}\text{-プログラム集合}}
\newcommand{\dtm}[1]{{\tt{#1}}\text{-データ}}
\newcommand{\data}[1]{{\tt{#1}}\text{-データ集合}}
\newcommand{\rtf}[3]{time^{\tt{#1}}_{\tt{#2}}({\tt{#3}})}
%% Barendiregt %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\T}{\mathbb{T}}
\newcommand{\V}{\mathbb{V}}
\newcommand{\cT}{\mathcal{T}}
\newcommand{\uhr}{\upharpoonright}
\newcommand{\thra}{\twoheadrightarrow}
\newcommand{\lama}{\lambda \! \! \to}
%% HoTT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\U}{\mathcal{U}}
\newcommand{\id}{\textrm{id}}
\newcommand{\refl}{\textrm{refl}}
\newcommand{\ap}{\textrm{ap}}
\newcommand{\apd}{\textrm{apd}}
\newcommand{\pr}{\textrm{pr}}
\newcommand{\tp}{\textrm{transport}}
\newcommand{\qinv}{\textrm{qinv}}
\newcommand{\iseq}{\textrm{isequiv}}
\newcommand{\peq}{\textrm{pair}^=}
\newcommand{\sig}[3]{\sum_{{#1} : {#2}} {#3}\ ({#1})}
\newcommand{\0}{\textbf{0}}
%\newcommand{\1}{\textbf{1}}
%\newcommand{\2}{\textbf{2}}
\newcommand{\fune}{\textrm{funext}}
\newcommand{\happ}{\textrm{happly}}
\newcommand{\ua}{\textrm{ua}}
\newcommand{\ide}{\textrm{idtoequiv}}
\newcommand{\set}[1]{\textrm{isSet({#1})}}
\newcommand{\fib}{\textrm{fib}}
\newcommand{\iscont}{\textrm{isContr}}
\newcommand{\total}{\textrm{total}}
\newcommand{\idtoeqv}{\textrm{idtoeqv}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{tocdepth}{2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\title{$q$-類似のCoqによる形式化}
\author{アドバイザー $\colon$ Jacques Garrigue教授\\
           学籍番号 $\colon$ 322101289\\
           氏名 $\colon$ 中村　薫}
\date{\today}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{序文}
\subsubsection*{主結果}
本論文の主結果は, $q$-類似の初等的な結果をCoqによって形式化するものである. 
形式化とは, 証明のために用意された人工言語に数学的な主張とその証明を翻訳し, 証明が論理学の推論規則に沿って正しく書かれていることをコンピュータを用いて機械的に検証することである.   また Coq はこの形式化を行うためのソフトウェアの一つであり, このようなソフトウェアを総称して定理証明支援系と呼ぶ.

具体的な形式化の対象はVictor Kac, Pokman Cheungの{\it Quantum Calculus}\cite{Kac}の4章(4.1)式の$q$-Taylor 展開, 及びその系として得られる Gauss's binomial formula である. 
本論文での$q$-類似に関する定義や定理, 証明は\cite{Kac}によるものだが, その形式化を行ったという点において独自性がある. 形式化したコード全体は\url{https://github.com/nakamurakaoru/q-analogue/tree/thesis}\cite{coq qana}にある. q\_analogue.v が\cite{Kac}の形式化をしたファイルであり, q\_tool.v は直接$q$-類似に関係はしないが, 形式化をするために自分で用意した補題をまとめたファイルである(どちらもテキストファイルである). 本論文の主目的である$q$-Taylor展開, Gauss's binomial formula はそれぞれ q\_analogue.v の1417行目, 1512行目にある. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{$q$-類似}
$q$-類似は, 学部4年次に卒業研究のテーマとして扱ったものである. 初めは Euler の分割に登場し, その後 Gauss や Heine らによって超幾何関数の研究の中で進展していった. $q$-類似を系統的に発展させたのは Jackson であり, また$q$-積分の概念も彼によって導入された. 

$q$-類似とは, 実数パラメータ$q$, 実数上の関数$f$に対して
\[
  D_q f(x) \coloneqq \frac{f(qx) - f(x)}{(q - 1) x}
\]
で定義される$q$-微分を出発点とし, この$q$-微分に対してうまく振る舞い, かつ$q$を極限で$1$に近づけると通常の定義に一致するように数学の諸概念を一般化するものである.
例えば, 自然数$n$について$x^n$を定義に沿って$q$-微分すると, 
\[
  D_q x^n = \frac{(qx)^n - x^n}{(q - 1) x} = \frac{q^n - 1}{q - 1} x^{n - 1}
\]
となる. 通常の微分では, $(x^n)' = n x^{n - 1}$となることと比較して, $n$の$q$-類似$[n]$を
\[
  [n] = \frac{q^n - 1}{q - 1}
\]
と定める. また, $(x - a)^n$の$q$-類似は, 
\[
  (x - a)^n_q \coloneqq \begin{cases}
                                  1 & (n = 0) \\
                                  (x - a) (x - qa) \cdots (x - q^{n - 1} a) & (n \ge 1)
                                \end{cases}
\]
と定義することで, $q$-微分と自然数の$q$-類似に対してうまく振る舞う, つまり
\[
  D_q (x - a)^n_q = [n](x - a)^{n - 1}_q
\]
が成り立つ. 更に, 階乗と二項係数の$q$-類似をそれぞれ
\begin{align*}
  [n]! &\coloneqq \begin{cases}
                        1 & (n = 0)\\
                        [n] \times [n   - 1] \cdots [1] & (n \ge 1)
                      \end{cases}\\
  \qcoe{n}{j} &\coloneqq \frac{[n]!}{[j]![n - j]!}
\end{align*}
で定めれば, $q$-Taylor展開, Gauss's binomial formula は以下のように書ける. 
\begin{itembox}{$q$-Taylor展開}
  $f(x)$を$N$次の実係数多項式とする. 任意の$c \in \R$について
  \[
    f(x) = \sum_{j = 0}^N (Dq^j f) (c) \frac{(x - c)^j_q}{[j]!}
  \]
  が成り立つ. 
\end{itembox}
\begin{itembox}{Gauss's binomial formula}
  $x$, $a \in \R$, $n \in \Z_{>0}$について
  \[
    (x+a)^n_q = \sum_{j=0}^n \qcoe{n}{j} q^{\frac{j(j-1)}{2}} a^j x^{n-j}
  \]
  が成り立つ. 
\end{itembox}
この2つを形式化することが本論文の主目的である. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Coq}
Coqとは, 前述のとおり定理証明支援系の1つであり, 人間がチェックすることが難しい複雑な証明でも正しさが保証され, また証明付きプログラミングにも応用される. Mizar, Isabelle/HOL等他にも定理証明支援系は存在するが, 修士1年次後期に履修した授業でCoqの使い方を学んだため, 今回の形式化に利用した. 

Coqは型付き$\lambda$計算という理論に基づいている. $\lambda$計算とは, 大まかにいえば計算の実行をモデル化したもので, Church によって考案された. その後, もともとは Russell のパラドクスを回避するために Russell 自身によって導入された型理論と結びついて型付き$\lambda$計算(こちらも Church によって考案された)として発展し, Martin-L\"{o}fによって直観主義型理論が開発され, 構成主義的な数学の基礎付けがなされた. 更により表現力の高い$\lambda$計算の研究が続けられ, Coquand と Huet の開発したCoC(Calculus of Constructions) と呼ばれる2階述語論理よりも表現力の高い型付き$\lambda$計算を用いてCoq が開発された. この CoC を用いていることから, Coq には補題とその証明を同じ言語で記述できるという特徴がある. また, 現在の Coq には Paulin-Mohring によって帰納的型を導入した$\lambda$計算である CIC (Calculus of Inductive Constructions)が用いられている. 

$\lambda$計算については修士1年次に少人数クラスで学習した内容であるため, Coq との関係にも触れつつ本論文でも説明を加える. 更に, 型と形式化に関する数学の理論として, Homotopy Type Theory がある. これについては修士2年次に少人数クラスで学んだため, $q$-類似の形式化とは章を分け, 少人数クラスのまとめとして概要を述べる. 
今回の証明に関しては, Coqの標準ライブラリ \cite{coq sl}に加えて, 数学の証明のために整備されたライブラリ群である mathcomp \cite{coq mc}も用いている. 
Coqが用いられた有名な例として, 四色定理や Feit-Thompson の定理(奇数位数定理)などがあり, それらも mathcomp に基づいている. 

実際に Coq で定義, 補題, 証明を表すコードは例えば以下のようなものである(\cite{coq qana} q\_analogue.v 16-25行目, ただし説明のためコードに変更を加えている).
\begin{lstlisting}{Coq}
Definition dq (f : R -> R) x := f (q * x) - f x.

Lemma dq_prod f g x :
  dq (f ** g) x = (f (q * x)) * dq g x + (g x) * dq f x.
Proof.
  rewrite /dq.
  rewrite !mulrBr 
  rewrite [g x * f (q * x)]mulrC
  rewrite [g x * f x]mulrC
  by rewrite subrKA.
Qed. \end{lstlisting}
基本的には{\tt Lemma}コマンドで証明したい補題の主張(を Coq にあわせて翻訳したもの)を書き, {\tt Proof}以下にタクティックとよばれる命令を書くことで証明を進め, 証明が完了したところで{\tt Qed}コマンドを書くというのが一連の流れである. {\tt Qed}コマンドは Coq にその補題を登録する機能があるため, 他の補題の証明に利用することができる. また, {\tt Definition}コマンドで自分で新しく関数を定義することができる. 

上記の例について見てみると,  
まず{\tt Definition}で {\tt dq}という名前の関数を定義している. {\tt $\coloneqq$}の左の{\tt f $\colon$ R $\to$ R}と{\tt x}は関数{\tt dq}の引数を表しており, $:=$の右側は関数の定義である. 
これは, 通常の数学での
\begin{screen}
実数上の関数$f$と実数$x$に対して, 
\[
  d_q f (x) \coloneqq f(qx) - f(x)
\]
と定める. 
\end{screen}
という定義を形式化したものである. 

次に{\tt Lemma}で補題の主張を書いている. {\tt dq\_prod}は補題の名前であり, 他の証明に用いる際に使えるように名前を付けている. {\tt $\colon$}の左側の{\tt f}, {\tt g}, {\tt x}がこの補題の引数であり, {\tt $\colon$}の右側が補題の主張である. この{\tt Lemma}は, 
\begin{screen}
関数$f$, $g$と$x \in \R$について, 
\[
  d_q (f(x)g(x)) = f(qx)d_qg(x) + g(x)d_qf(x)
\]
が成り立つ.
\end{screen}
という補題の形式化である. 
更に, {\tt Proof}以下について, {\tt rewrite}とは等式変形を行う命令であり, {\tt rewrite /dq}であれば{\tt dq}を定義に基づいて計算していて, {\tt rewrite !mulrBr}であれば積と差についての分配法則をできる限り繰り返している. {\tt mulrC}は積の交換律のことで, 
{\tt [g x * f (q * x)]mulrC}であれば{\tt g x * f (q * x)}を{\tt f (q * x) * g x}に, 
{\tt [g x * f  x]mulrC}であれば{\tt g x * f x}を{\tt [f x * g x]}に書き換えている. 
{\tt by rewrite subrKA}は同じものの引き算は$0$になるという書き換えをし, 更にその書き換えで証明が完了することを表している. 
最後に{\tt Qed}と書くことで, {\tt dq\_prod}という補題を他の証明で使えるようになる. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{構成}
最後に構成について述べる. 
まず\ref{sec qana}節で$q$-類似の概要について説明し, 
\ref{sec lambda}節で修士1年次に少人数クラスで学習したH.P.Barendregtの{\it Lambda Calculi with Types}\cite{Bar}に沿って, 型付き$\lambda$計算について述べる. 
\ref{sec coq}節は Coq の概要についてで, 特に\ref{ssec coq_use}節でCoq や mathcompの使い方を具体例を交えて説明するが, より詳細な情報については萩原 学/アフェルト・レナルドの{\it Coq/SSReflect/Mathcomp}\cite{Hag}等を参照のこと. 
これらの準備のもと, \ref{sec form}節から本題の形式化に入る. \cite{Kac}での定義, 定理を述べた後, その形式化を与え, 必要であれば形式化をするにあたっての注意点を述べることを繰り返すという流れである. 
証明の方針等は基本的に\cite{Kac}の通りであるが, \ref{ssec poly}節では一部\cite{Kac}から離れ, 多項式として$q$-微分や$q$-二項式を定義しなおして形式化を行っている. これらの新たな定義が多項式に対してのもとの定義を適用したものと一致していることの証明も行っている. また, \ref{chap hott}章で修士2年次に少人数クラスで学習した内容についてまとめている. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{謝辞}
形式化の方針やCoq の使い方等, 本論文の作成において終始熱心に指導してくださった, アドバイザーである Jacques Garrigue 教授に心からの感謝を申し上げます. 

今回の形式化の題材に選んだ$q$-類似について指導してくださった学部4年次の指導教員である古庄英和教授に感謝の意を表します. 

多元数理科学研究科研究員の才川隆文氏から数多くの的確な助言をいただきました. 感謝申し上げます. 

最後に, 研究室の皆様には常に刺激的な議論とアドバイスを頂き, 精神的にも絶えず支えられていました. 本当にありがとうございます. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{自主学習・研究報告} \label{chap thesis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{$q$-類似} \label{sec qana}
本節では, 形式化について説明する\ref{sec form}節では詳細には立ち入らない$q$-類似の性質や, $q$-Taylor展開以降で\cite{Kac}で取り上げられている内容について述べる. 
%\ref{ssec infsum}, 
\ref{ssec jacobi}節は極限や無限和に関するものであるため形式化はできていない. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$q$-微分について成り立つ諸性質} \label{ssec qprops}
$q$-微分は\cite{Kac}において, まず$q$-差分を, $q$, $x \in \R$, 実数上の関数$f$について
\[
  d_q f(x) = f(qx) - f(x)
\]
を定義し, この$d_q$を用いて
\[
  D_q f(x) = \frac{d_q f(x)}{d_q x}
\]
と定めている. 

通常の微分は線形作用素であり, また積の微分法や商の微分法などの性質が成り立つのであった. これらの性質は$q$-微分ではどうなるのであろうか. まずは線形性について見ていく. $a$, $b \in \R$, 実数上の関数$f$, $g$について, $D_q$を直接計算すると以下のようになる. 
\begin{align*}
  D_q (af(x) + bg(x)) &= \frac{(af(qx) + bf(qx)) - (af(x) + bf(x))}{(q - 1)x}\\
                           &= \frac{af(qx) - af(x)}{(q - 1)x} + \frac{bg(qx) - bg(x)}{(q - 1)x}\\
                           &= a \frac{f(qx) - f(x)}{(q - 1)x} + b \frac{g(qx) - g(x)}{(q - 1)x}\\
                           &= a D_q f(x) + b D_q g(x)
\end{align*}
よって, 通常の微分と変わらない形で成り立つ(\cite{Kac} p2). 一方で積の微分法はそのままの形では成り立たない. このことを確認するために, まず$q$-差分が積についてどう振る舞うかを観察する. 実数上の関数$f$, $g$について計算してみると 
\begin{align*}
  d_q (f(x)g(x)) &= f(qx)g(qx) - f(x)g(x) \\
                    &= f(qx)g(qx) - f(qx)g(x) + f(qx)g(x) - f(x)g(x)\\
                    &= f(qx) d_q g(x) + g(x) d_q f(x)
\end{align*}
となるため, $D_q$は
\begin{align*}
  D_q(f(x)g(x)) &= \frac{d_q(f(x)g(x))}{(q - 1)x}\\
                   &= \frac{f(qx) d_q g(x) + g(x) d_q f(x)}{(q - 1)x}\\
                   &= f(qx) \frac{d_q g(x)}{(q - 1)x} + g(x) \frac{d_q f(x)}{(q - 1)x}
\end{align*}
となり, 積の$q$-微分法は
\[
  D_q (f(x) g(x)) = f(qx) D_q g(x) + g(x) D_q f(x) \quad \text{(\cite{Kac} p3 (1.11))}
\]
となる. また, $f(x)g(x) = g(x)f(x)$から, $f$と$g$を入れ替えることで
\[
  D_q (f(x) g(x)) = f(x) D_q g(x) + g(qx) D_q f(x) \quad \text{(\cite{Kac} p3 (1.12))}
\]
も得られる. 次に, 商の微分法については, 
\[
  g(x) \cdot \frac{f(x)}{g(x)} = f(x)
\]
という等式の両辺を$q$-微分し, 左辺について1つ目の積の$q$-微分法を適用することで
\[
  g(qx) D_q \left( \frac{f(x)}{g(x)} \right) + \frac{f(x)}{g(x)} D_q g(x) = D_qf (x)
\]
となるので, 式変形することで商の$q$-微分法
\[
  D_q \left( \frac{f(x)}{g(x)} \right) = \frac{g(x) D_q f(x) - f(x) D_q g(x)}{g(x) g(qx)}
  \quad \text{\cite{Kac} p3 (1.13)}
\]
が得られる. 2つ目の積の$q$-微分法を適用すれば, もう一つの商の微分法
\[
  D_q \left( \frac{f(x)}{g(x)} \right) = \frac{g(qx) D_q f(x) - f(qx) D_q g(x)}{g(x) g(qx)}
  \quad \text{\cite{Kac} p3 (1.14)}
\]
が得られる. 

更に, 合成関数の$q$-微分法については一般的なルールは存在せず, $u(x) = \alpha x^{\beta}$
のときについてのみ
\[
  D_q f (u (x)) = (D_q^{\beta} f)(u(x)) \cdot D_q u(x) \quad \text{(\cite{Kac} p4 (1.15))}
\]
が成り立つことが知られている(証明は\cite{Kac} p3, p4を参照). 

これらの性質はすべて形式化できており, $D_q$の線形性, 積の$q$-微分法の1つ目・2つ目, 商の$q$-微分法の1つ目・2つ目, 合成関数の$q$-微分法はそれぞれこの順に{\tt Dq\_is\_linear}, {\tt Dq\_prod}, {\tt Dq\_prod'}, {\tt Dq\_quot}, {\tt Dq\_quot'}, {\tt qchain}という補題名で\cite{coq ana}のq\_analogue.vに登録してある. 

また, 今回の主目的である$q$-Taylor展開には利用しないが, 二項係数の$q$-類似について, 通常の二項係数において Pascal の法則が成り立つことの$q$-類似版として, $n > j$をみたす$1$以上の整数$n$, $j$について
\[
  \qcoe{n}{j} = \qcoe{n - 1}{j - 1} + q^j \qcoe{n - 1}{j} \quad \text{(\cite{Kac} p17 (6.2))}
\]
が成り立つことが証明されている(\cite{Kac} p18参照). この補題も形式化できており, \cite{coq qana}のq\_analogue.vの{\tt q\_pascal}という補題である.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{無限和への拡張} \label{ssec jacobi}
あえてパラメータを増やす$q$-類似を考える利点の一つとしては, 証明が複雑な定理に対してより簡単な別証明を与えられる場合があることである. 例えば, 以下のJacobiの三重積(\cite{Kac} p35 Theorem 11.1)はその一例である. 
\begin{screen}
$z$, $q \in \R$, $|q| < 1$として, 
\[
  \sum_{n = -\infty}^{\infty} q^{n^2} z^n =
  \prod_{n = 1}^{\infty} (1 - q^{2n})(1 + q^{2n - 1}z)(1 + q^{2n - 1}z^{-1})
\]
が成り立つ. 
\end{screen}
これは楕円関数論の文脈で登場する恒等式であるが(\cite{Ume} p144 (3.47)等を参照), $q$-類似で得られる式
\begin{align*}
  (1 + x)^{\infty}_q &=
    \sum_{j = 0}^{\infty} q^{j(j - 1)/2} \frac{x^j}{(1 - q) (1 - q^2) \cdots (1 - q^j)}
     \quad(\text{\cite{Kac} p30 (9.3)式}) \\
  \frac{1}{(1 - x)^{\infty}_q} &=
    \sum_{j = 0}^{\infty} \frac{x^j}{(1 - q) (1 - q^2) \cdots (1 - q^j)}
      \quad(\text{\cite{Kac} p30 (9.4)式})
\end{align*}
を用いることで簡単に証明できる. これらの等式は Euler によって発見されたことから, \cite{Kac}ではそれぞれ Euler's first and second identities の意で E1, E2 と呼んでいる. 

E1については, Gauss's binomial formula を無限に拡張することで得られる. 
まず, Gauss's binomial formula において, $x = 1$, $a = x$とすれば
\[
  (1 + x)^n_q = \sum_{j = 0}^n q^{j (j - 1) / 2} \qcoe{n}{j} x^j
\]
となる. ここで$|q| < 1$とすると, 
\[
  \lim_{n \to \infty} \qcoe{n}{j} =
  \lim_{n \to \infty} \frac{(1 - q^n)(1 - q^{n - 1}) \cdots (1 - q^{n - j + 1})}
                                  {(1 - q) (1 - q^2) \cdots (1 - q^j)} =
  \frac{1}{(1 - q) (1 - q^2) \cdots (1 - q^j)}
\]
となるので,  
\[
  (1 + x)^{\infty}_q = \sum_{j = 0}^{\infty} q^{j (j - 1)/2}
  \frac{x^j}{(1 - q) (1 - q^2) \cdots (1 - q^j)}
\]
が得られる. また, E2 については, 任意の形式的冪級数に対して, 無限和に拡張した$x = 0$まわりでの$q$-Taylor展開が成り立つこと, $|q| < 1$のとき$\lim_{n \to \infty} [n] = \frac{1}{1 - q}$となることから証明できる. 

更に, E1, E2をもとにして指数関数$e^x$の$q$-類似$e^x_q$, $E^x_q$を考えることができ(\cite{Kac} p30 (9.7), p31 (9.10)), 
また$e^x_q$, $E^x_q$を用いて$q$-三角関数を定義したり(\cite{Kac} p33)と, E1, E2 は\cite{Kac}の中でも重要な式である. 

有限の範囲で扱うことができ,  E1, E2 の基礎となる等式であることが今回の形式化の目標としてGauss's binomial formula と$q$-Taylor展開を選んだ理由である. 序文で書いたように, 無限和を含む形式化は今後の課題である. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{型付き$\lambda$計算} \label{sec lambda}
この節では, Coq の基礎となっている理論である$\lambda$計算について\cite{Bar}を基に説明する. 初めは型無しの$\lambda$計算について述べ, その後に型付き$\lambda$計算の説明をしていく. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$\lambda$計算} \label{ssec lambdacal}
まず型のない$\lambda$計算を定義する. 初めに, $\lambda$計算がどのようなものなのかについての概要を説明し, その後厳密な定義に移る.

\subsection*{$\lambda$計算の概要}
$\lambda$計算には, 抽象と適用の2つの基本的な操作がある. まず, 抽象については, 「式から関数を作る操作」と捉えることができる. $M$を$\lambda$計算における式($\lambda$計算においてはこれを$\lambda$項と呼ぶ)だとすると, 
\[
  \lambda x . M
\]
で, 「$x$を変数とする関数」を表すことになる. 
例えば, $M$が$x^2 + 3xy + 4$という式であれば, 
\begin{itemize}
  \item $\lambda x . (x^2 + 3xy + 4)$
  \item $\lambda xy . (x^2 + 3xy + 4)$
  \item $\lambda z . (x^2 + 3xy + 4)$
\end{itemize}
はそれぞれ, 1つ目は$x \mapsto (x^2 + 3xy + 4)$という$x$についての2次関数, 
2つ目は$(x, y) \mapsto (x^2 + 3xy + 4)$という$x, y$についての2変数関数を表す. 
3つ目は, $(x^2 + 3xy + 4)$は変数$z$を含まないので, 定数関数を表すことになる.

もう1つの操作である適用は, 2つの$\lambda$項$M$と$N$を並べて, 
\[
  MN
\]
と書かれ, 直観的には「関数$M$に値$N$を代入する」ことを示している. 
例えば, $M$が$\lambda x . (3x + 2)$, $N$が$4$であれば, 
\[
  (\lambda x . (3x + 2))\ 4 = 3 \cdot 4 + 2\ (= 14)
\]
となる. 一般には, $[x \coloneqq N]$で$x$に$N$を代入することを表すとして, 
\[
  (\lambda x. M)\ N = M[x\coloneqq N]
\]
と書く. 

\subsection*{$\lambda$計算の定義}
ここから実際の$\lambda$計算の定義に入る. 
\begin{shadebox}
  \begin{df}{(\cite{Bar} Definition 2.1.1)}
    $V = \{ v, v', v'', \ldots \}$を無限個の変数の集合とする. 
    $\lambda$項全体の集合$\Lambda$を, 以下のように帰納的に定義する. 
    \begin{alignat*}{3}
      &x \in V& \quad &\Lra& \quad &x \in \Lambda \\
      &M, N \in \Lambda& &\Lra& &(MN) \in \Lambda \\
      &M \in \Lambda, x \in V& &\Lra& &(\lambda x . M) \in \Lambda
    \end{alignat*}
    抽象構文を用いると, 以下のようにも書ける. 
    \begin{align*}
      &V ::= v\ |\ V' \\
      &\Lambda ::= V\ |\ (\Lambda \Lambda)\ |\ (\lambda V \Lambda)
    \end{align*}
  \end{df}
\end{shadebox}
\brmk
抽象構文とは, $::=$の左側の集合を, 右側の$|$で区切られた各構成要素で定義する書き方であり, 例えば$V ::= v\ |\ V'$であれば, 
「$V$という集合は, $v$もしくは$V$の要素に$'$をつけたものからなる」
という意味で, $\Lambda ::= V\ |\ (\Lambda \Lambda)\ |\ (\lambda V \Lambda)$であれば, 
「$\Lambda$という集合は, $V$の要素か, $\Lambda$の要素を2つ並べたものか, $\lambda$という記号・$V$の要素・$\Lambda$の要素をこの順で並べたものからなる」
という意味である. 
\ermk
\begin{ex}
  $v$, $(v v')$, $\lambda v (v v')$, $((\lambda v (vv''))v')$などが$\lambda$項の例である. 
\end{ex}
今後, 表記上のルールや省略を以下のように約束する. 
\begin{enumerate}
  \item $x, y, z, \ldots$ で任意の変数を, $M, N, L, \ldots$で任意の$\lambda$項を表す. 
  \item $F M_1 \cdots M_n$で$(\cdots ((F M_1) M_2)\cdots M_n)$を, 
           $\lambda x_1 \cdots x_n .M$で
           $(\lambda x_1 (\lambda x_2 (\cdots (\lambda x_n(M))\cdots)))$
            を表す. 
  \item 最も外側の()は書かない. 
\end{enumerate}
次に, 束縛変数と自由変数, $\lambda$項の間の$\equiv$, 代入を定義する. 
\begin{shadebox}
  \begin{df}{(\cite{Bar} Notation 2.1.4, Definition 2.1.5)} \label{def FV}
    $M, N, P, Q \in \Lambda$, $x, y \in V$とする. 
    \begin{enumerate}
      \item $M$の自由変数の集合$FV(M)$を, 以下のように帰納的に定義する. 
        \begin{alignat*}{3}
          &FV(x)& \quad &=& \quad &\{ x \} \\
          &FV(MN)& &=& &FV(M) \cup FV(N) \\
          &FV(\lambda x. M)& &=& &FV(M) - \{ x \}
        \end{alignat*}
      \item $M$に現れる変数のうち, 自由変数でないものを束縛変数と呼ぶ. 
               また, $M$と$N$が等しいか, 束縛変数の名前をつけかえることで互いにうつりあうとき,
               $M \equiv N$と書く.
      \item $M$において$x$に$N$を代入した結果$M[x \coloneqq N]$を, 
               以下のように帰納的に定義する. 
        \begin{alignat*}{3}
        &y\ [x \coloneqq N]& \quad &\equiv& \quad &\begin{cases}
                                                                          N & x = y \\
                                                                          y & x \neq y
                                                                       \end{cases} \\
        &(PQ)\ [x \coloneqq N]& &\equiv& &(P [x \coloneqq N])\ (Q [x \coloneqq N]) \\
        &(\lambda y.M)\ [x \coloneqq N]& &\equiv& &\begin{cases}
                                                \lambda y .(M [x \coloneqq N]) & x \neq y \\
                                                \lambda y .M & x = y
                                                                       \end{cases}
        \end{alignat*}
    \end{enumerate}
  \end{df}
\end{shadebox}
\bex
  $\lambda$に束縛されている変数が束縛変数, それ以外が自由変数である. 例えば
  \[
    \lambda x.\ x + y
  \]
  であれば束縛変数は$x$, 自由変数は$y$である. また, 
  \[
    \lambda x\ y.\ x(y + z) - w
  \]
  であれば束縛変数は$x$, $y$で, 自由変数は$z$, $w$である. 
\eex
\begin{rmk}{(\cite{Bar} Notation 2.1.4)}
Definition \ref{def FV}2.について, 例えば, 
\begin{align*}
  (\lambda x .x) z \equiv (\lambda x .x) z \\ 
  (\lambda x .x) z \equiv (\lambda y .y) z \\
  (\lambda x .x) z \nequiv (\lambda x .y) z
\end{align*}
となる. 
\end{rmk}
\begin{rmk}
  束縛変数は, 自由変数とは異なる名前とする. 例えば, $y\ (\lambda y . xy)$は
  $y\ (\lambda y' . xy')$などに書き換える. 
\end{rmk}
本節の最後に, 適用である$\beta$-簡約を定義する. 
\begin{shadebox}
  \begin{df}{(\cite{Bar} Definition 2.3.2)}
    $\Lambda$上の二項関係$\to_{\beta}$(1ステップ$\beta$-簡約), 
    $\thra_{\beta}$($\beta$-簡約), 
    $=_{\beta}$を, 
    以下のように帰納的に定義する. 
    \begin{enumerate}
      \item \begin{enumerate}
        \item $(\lambda x .M)N \to_{\beta} M\ [x \coloneqq N]$
        \item $M \to_{\beta} N \Lra ZM \to_{\beta} ZN, MZ \to_{\beta} NZ,
                 \lambda x .M \to_{\beta} \lambda x .N$
               \end{enumerate}
      \item \begin{enumerate}
        \item $M \thra_{\beta} M$
        \item $M \to_{\beta} N \Lra M \thra_{\beta} N$
        \item $M \thra_{\beta} N, N \thra_{\beta} L \Lra M \thra_{\beta} L$
               \end{enumerate}
      \item \begin{enumerate}
        \item $M \thra_{\beta} N \Lra M =_{\beta} N$
        \item $M =_{\beta} N \Lra N =_{\beta} M$
        \item $M =_{\beta} N, N =_{\beta} L \Lra M =_{\beta} L$
               \end{enumerate}
    \end{enumerate}
  \end{df}
\end{shadebox}
\begin{ex}
  \begin{enumerate}
    \item $(\lambda x . xyz)y \to_{\beta} yyz$である. 
    \item $(\lambda x . xy)(\lambda z . z) \to_{\beta} (\lambda z . z) y \to_{\beta} y$より, 
             $(\lambda x . xy)(\lambda z . z) \thra_{\beta} y$である. 
  \end{enumerate}
\end{ex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$\lama$とその拡張}
この節では, 単純型付きラムダ計算である$\lama$と, その拡張である$\lambda 2$及び$\lambda$Pを導入する. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% label prop1, 2 %%
%% ref prop1, 2 %%
\subsection*{$\lama$}
大まかに言えば, 型とはある要素が属する集合のようなものである. 
$\lama$は最も単純な型付き$\lambda$計算であり, 関数の型を表現できる. 
基本的なルールは, 
\begin{itemize}
  \item $\sigma$から$\tau$への関数に$\sigma$の値を適用すると, 
    その結果の型は$\tau$である
  \item
    変数$x$の型が$\sigma$で, $\lambda$項$M$の型が$\tau$のとき, 
    $\lambda x.\ M$の型は$\sigma \to \tau$である. 
\end{itemize}
以下, \cite{Bar}での定義を見ていく. 
\begin{shadebox}
  \begin{df}{(\cite{Bar} Definition 3.1.1)}
    $\lama$の型の集合Type($\lama$)は, 以下のように帰納的に定義される. 
    $\T$ = Type($\lama$)と書くことにする. 
    \begin{alignat*}{2}
      &\alpha, \alpha',\ldots \in \T& &\text{(型変数)}\\
      &\sigma, \tau \in \T \Rightarrow (\sigma \to \tau) \in \T&  \quad &\text{(関数型)}
    \end{alignat*}
    抽象構文を用いれば, 
    \[
      \T ::= \V \ |\ \V \to \V
    \]
    と書ける. ここで, $\V$は, 
    \[
      \V ::= \alpha \ | \ \V'
    \]
    である.
  \end{df}
\end{shadebox}
\begin{rmk}{(\cite{Bar} Notation 3.1.2)}
  \begin{enumerate}
    \item $\sigma_{1}, \ldots \sigma_{n} \in \T$のとき, 
      \[
        \sigma_1 \to \sigma_2 \to \cdots \to \sigma_n
      \]
      と書いた場合, 
      \[
        (\sigma_1 \to (\sigma_2 \to \cdots \to (\sigma_{n-1} \to \sigma_n) \cdots ))
      \]
      を表すものとする(右結合).
    \item $\alpha$, $\beta$, $\gamma$, $\ldots$で型変数を表す. 
  \end{enumerate}
\end{rmk}
\begin{shadebox}
  \begin{df}{(\cite{Bar} Definition 3.1.3)}($\lama$-Curry)
    \begin{enumerate}
      \item $M \in \Lambda$, $\sigma \in \T$のとき, $M \colon \sigma$の形を
        statement(文)という. このとき, 型$\sigma$を文の predicate (述語), 項$M$を
        文の subject (主語)という. 
      \item 変数(項)を主語とする文を declaration (宣言)という.
      \item 異なる変数を主語とする宣言の集合を basis (基底)という.
    \end{enumerate}
  \end{df}
\end{shadebox}
\begin{shadebox}
  \begin{df}{(\cite{Bar} Definition 3.1.4)}
    文$M \colon \sigma$が基底$\Gamma$から導出される
    ($\Gamma \vdash_{\lama\text{-Curry}} M \colon \sigma$ or 
    $\Gamma \vdash_{\lama} M \colon \sigma$ or 
    $\Gamma \vdash M \colon \sigma$と書く)のは, $\Gamma \vdash M \colon \sigma$が
    以下のルールから導かれるときである. 
    \begin{itembox}[c]{導出規則0}
      \begin{alignat*}{3}
  (x \colon \sigma) \in \Gamma &\quad& &\Rightarrow& \quad
    &\Gamma \vdash x \colon \sigma \\
  \Gamma \vdash M \colon (\sigma \to \tau),\ \Gamma \vdash N \colon \sigma &&
    &\Rightarrow& &\Gamma \vdash (MN) \colon \tau \\
  \Gamma,\ x \colon \sigma \vdash M \colon \tau && &\Rightarrow& 
    &\Gamma \vdash (\lambda x . M) \colon (\sigma \to \tau) 
      \end{alignat*}
    \end{itembox}
    ここで$\Gamma ,\ x \colon \sigma$は$\Gamma \cup x \colon \sigma$のことである.
  \end{df}
\end{shadebox}
$\Gamma = \{ x_1 \colon \sigma_1 , \ldots , x_n \colon \sigma_n\}$
(または$\Gamma = \emptyset$)のとき, $\Gamma \vdash M \colon \sigma$を
$x_1 \colon \sigma_1 , \ldots , x_n \colon \sigma_n \vdash M \colon \sigma$
(または$\vdash M \colon \sigma$)と書く. 
導入規則は以下のようにも表される.
\begin{itembox}[c]{導出規則1}
  \begin{alignat*}{3}
    &(\text{axiom})& \quad &\Gamma \vdash x \colon \sigma& 
      &(x \colon \sigma) \in \Gamma \text{のとき}\\
    &(\text{$\to$-elimination})& 
      &\frac{\Gamma \vdash M \colon (\sigma \to \tau) \quad
        \Gamma \vdash N \colon \sigma}{\Gamma \vdash (MN) \colon \tau}& & \\
    &(\text{$\to$-introduction})& &\frac{\Gamma,\ x \colon \sigma \vdash M \colon \tau}
      {\Gamma \vdash (\lambda x . M) \colon (\sigma \to \tau)}& &
  \end{alignat*}
\end{itembox}
以下, 本論文においては, 導出規則1を用いる.
\begin{ex}%{(\cite{Bar} Example 3.1.5)}
$\lambda$項に対してある型が付くことを示すには, 
      導出規則を逆向きに使って辿る方法, つまり, 
      
        「示したい型付けから始めて, その導出のために必要となる前提を順に上に書き加えていく
        ことを繰り返し, 変数のみとなった時点で, その変数に対して矛盾なく型がついているかを
        確認する」
        
      という手順が便利である. いくつか例を見てみる. 
  \begin{enumerate}
    \item  任意の$\sigma, \tau \in \T$について, 
      $\vdash (\lambda x y . x) \colon (\sigma \to \tau \to \sigma)$であることを確認する. 
      まず, $\lambda x y . x$の最も大きな構造は抽象である. 
      抽象に対して型を割り当てる規則は$\to$-introduction なので, 
      \[
        \frac{x \colon \sigma \vdash (\lambda y . x) \colon (\tau \to \sigma)}
          {\vdash (\lambda x y . x) \colon (\sigma \to \tau \to \sigma)}
      \]
        というように, 必要となる前提を書き加える. ここで, この書き加えた前提を見てみると, 
        これも抽象の形をしているため, 
      \[
        \frac{x \colon \sigma,\ y \colon \tau \vdash x \colon \sigma}
       {\displaystyle{\frac{x \colon \sigma \vdash (\lambda y . x) \colon (\tau \to \sigma)}
          {\vdash (\lambda x y . x) \colon (\sigma \to \tau \to \sigma)}}}
      \]
      というように, さらに前提を書き加える. すると, 一番上の行が変数のみとなり, 
      $x$に対してともに$\sigma$が型付けられており, 矛盾なく型がついていることがわかるので, 
      $\vdash (\lambda x y . x) \colon (\sigma \to \tau \to \sigma)$が示せたことになる. 
      このように, 必要な前提を書き加え続けることで得られたものを導出木と呼ぶ. 
      \item 任意の$\sigma$, $\tau \in \T$について, 
        $\lambda xy . xy \colon (\sigma \to \tau) \to (\sigma \to \tau)$であることは, 
        \[
      \dfrac{x \colon (\sigma \to \tau), y \colon \sigma \vdash x \colon (\sigma \to \tau)
      \quad x \colon (\sigma \to \tau), y \colon \sigma \vdash y \colon \sigma}
          {\dfrac{x \colon (\sigma \to \tau), y \colon \sigma \vdash xy \colon \tau}
          {\dfrac{x \colon (\sigma \to \tau) \vdash \lambda y . xy \colon (\sigma \to \tau)}
          {\vdash \lambda xy . xy \colon (\sigma \to \tau) \to (\sigma \to \tau)}}}
        \]
        という導出木により確認できる. 
    \item $\lama$においては, $\lambda x . xx$には型が付かない. 実際, 
    \[
      \Gamma \vdash \lambda x. xx \colon \sigma
    \]
    と仮定すると, 抽象の形であるから, $\sigma = (\sigma_1 \to \sigma_2)$となる
    $\sigma_1$, $\sigma_2$が存在して, 
    \[
      \frac{\Gamma, x \colon \sigma_1 \vdash xx \colon \sigma_2}
      {\Gamma \vdash \lambda x. xx \colon \sigma_1 \to \sigma_2}
    \]
    となるはずである. さらに, $xx$は適用の形なので, ある$\tau$が存在し, 
    \[
      \frac{\Gamma, x \colon \sigma_1 \vdash x \colon \tau \to \sigma_2
      \quad \Gamma, x \colon \sigma_1 \vdash x \colon \tau}
      {\displaystyle{\frac{\Gamma, x \colon \sigma_1 \vdash xx \colon \sigma_2}
      {\Gamma \vdash \lambda x. xx \colon \sigma_1 \to \sigma_2}}}
    \]
    となるはずである. しかし, $\lama$において, 同じ$x$に対して$\tau$と$\tau \to \sigma_2$
    の両方がつくことはありえない. よって, $\lambda x .xx$には型がつかない. 
  \end{enumerate}
\end{ex}
\subsection*{$\lambda 2$}
$\lama$の拡張の1つとして, $\lambda 2$を考える. $\lambda$2の特徴は型を$\forall$で抽象化できることである. 論理学における2階命題論理に対応し, $\lambda$2の「2」はここから来ている. 同じく論理学との関係を見ると, $\lama$は1階命題論理に対応する. 
\begin{shadebox}
  \begin{df}{(\cite{Bar} Definition 4.1.5)}
    $\lambda 2$の型の集合Type($\lambda 2$)を$\T$と書く. 
    このとき, $\T$は以下のように帰納的に定義される. 
    \[
      \T = \V \ |\ \T \to \T \ |\ \forall \V \T
    \]
  \end{df}
\end{shadebox}
\begin{rmk}{(\cite{Bar} Notation 4.1.6)}
  \begin{enumerate}
    \item $\forall \alpha_1 \cdots \alpha_n . \sigma$は, 
             $(\forall \alpha_1(\forall \alpha_2 \cdots (\forall \alpha_n (\sigma))\cdots))$
             を表す. 
    \item $\forall$の方が$\to$よりも結合が強い, すなわち, 
             $\forall \alpha \sigma \to \tau$は$(\forall \alpha \sigma) \to \tau$のことであり, 
             $\forall \alpha . \sigma \to \tau$は$\forall \alpha (\sigma \to \tau)$のことである.
  \end{enumerate}
\end{rmk}
\begin{shadebox}
  \begin{df}[\cite{Bar} Definition 4.1.7]
    $\lambda 2$の型導出規則を, 以下のように定める.
    \begin{alignat*}{3}
      &(\text{start rule})& \quad &\frac{(x \colon \sigma \in \Gamma)}
        {\Gamma \vdash x \colon \sigma}& &\\
      &(\text{$\to$-elimination})& 
        &\frac{\Gamma \vdash M \colon (\sigma \to \tau) \quad
          \Gamma \vdash N \colon \sigma}{\Gamma \vdash (MN) \colon \tau}& & \\
      &(\text{$\to$-introduction})& &\frac{\Gamma,\ x \colon \sigma \vdash M \colon \tau}
        {\Gamma \vdash (\lambda x . M) \colon (\sigma \to \tau)}& & \\
      &(\text{$\forall$-elimination})& &\frac{\Gamma, \vdash M \colon (\forall \alpha . \sigma)}
        {\Gamma \vdash M \colon (\sigma[\alpha \coloneqq \tau])}& & \\
      &(\text{$\forall$-introduction})& &\frac{\Gamma \vdash M \colon \sigma}
        {\Gamma \vdash M \colon (\forall \alpha . \sigma)}& &(\alpha \notin FV(\Gamma))
    \end{alignat*}
  \end{df}
\end{shadebox}
\begin{ex}{(\cite{Bar} Example 4.1.8)}
$\lambda 2$での型付けの例として, 以下のようなものがある. 
  \begin{align*}
    &\vdash (\lambda x . x) \colon (\forall \alpha . \alpha \to \alpha) \\
    &\vdash (\lambda x y . y) \colon (\forall \alpha \beta . \alpha \to \beta \to \beta) \\
    &\vdash (\lambda x . x x) \colon (\forall \alpha \alpha) \to (\forall \alpha \alpha) \\
  \end{align*}
ここで, 3つ目の例については, 
 \[
    \frac{\displaystyle
             {\frac{x \colon \forall \alpha \alpha \vdash x \colon \forall \alpha \alpha}
          {x \colon \forall \alpha \alpha \vdash x \colon \beta \to \alpha}} 
    \quad \displaystyle{\frac{x \colon \forall \alpha \alpha \vdash 
                                                                       x \colon \forall \alpha \alpha}
          {x \colon \forall \alpha \alpha \vdash x \colon \beta}}}
  {\displaystyle{\frac{x \colon \forall \alpha \alpha \vdash xx \colon \alpha}
  {\displaystyle{\frac{x \colon \forall \alpha \alpha \vdash xx \colon \forall \alpha \alpha}
        {\vdash (\lambda x. xx) \colon (\forall \alpha \alpha) \to (\forall \alpha \alpha)}}}}}
  \]
という導出木により確認できる. 型に$\forall$があることにより, $\lama$では型が付けられないような項についても, $\lambda 2$では型が付けられる場合がある. 
\end{ex}
\subsubsection*{$\lambda$P}
$\lambda$2とは別の拡張として, $\lambda$Pがある. Pは predicate のPであり, 述語論理に対応する. $\lambda$Pの特徴は依存関数型を扱えることと, 命題の証明のシミュレートを行えることである. これからは項と型を区別せず, まとめて擬式と呼ぶことにして, 以下のように定義する. 
\bdf[\cite{Bar} Definition 5.1.8]
  \begin{enumerate}
    \item $\lambda$Pの擬式全体$\cT$を以下のように定める. 
      \[
        \cT = V \ |\ C \ |\ \cT \cT \ |\ \lambda V:\cT.\ \cT \ |
        \ \textstyle{\prod} V:\cT.\ \cT
      \]
      ここで, $V$は変数全体, $C$は定数全体である. 
    \item $C$の中から2つ要素を選んで, $\ast$, $\square$と名付ける. 
      $\ast$は$\alpha : \ast$と書くことで$\alpha$が型であることを表す記号である. 
      また, この$\ast$に対し, $\K$を
      \[
        {\mathbb K} = \ast \ |\ \K \to \K
      \]
      と定めたとき, $k : \square$で$k$が$\K$に属することを表す記号である. 
  \end{enumerate}
\edf
型導出規則は以下の通り. ただし, $s$は$\ast$か$\square$のいずれかである. 
\bdf[\cite{Bar} Definition 5.1.9]
$\lambda$Pの型導出規則を, 以下のように定める. 
    \begin{alignat*}{3}
     &(\text{axiom})& \quad &\vdash \ast \colon \square& &\\
     &(\text{start-rule})&
        &\frac{\Gamma \vdash A : s}{\Gamma,\ x:A \vdash x : A}& &(x \notin \Gamma)\\
      &(\text{weakening rule})&
        &\frac{\Gamma \vdash A : B \quad \Gamma \vdash C : s}
                 {\Gamma,\ x:C \vdash A : B}& &(x \notin \Gamma)\\
      &(\text{type/kind formation})&
        &\frac{\Gamma \vdash A : \ast \quad \Gamma,\ x : A \vdash B : s}
                 {\Gamma \vdash (\Pi x : A.\ B) : s}& &\\
      &(\text{application rule})&
        &\frac{\Gamma \vdash F \colon (\Pi x : A .\ B) \quad
          \Gamma \vdash a \colon A}{\Gamma \vdash F a \colon B[x := a]}& & \\
      &(\text{abstraction rule})& &\frac{\Gamma,\ x \colon A \vdash b \colon B 
          \quad \Gamma \vdash (\Pi x : A .\ B) : s}
        {\Gamma \vdash (\lambda x : A.\ b) \colon (\Pi x : A .\ B)}& & \\
      &(\text{conversion rule})&
        &\frac{\Gamma \vdash A : B \quad \Gamma \vdash B' : s \quad B =_{\beta} B'}
                 {\Gamma \vdash A : B'}& &
    \end{alignat*}
\edf
\bex[\cite{Bar} p86]
$\lambda$Pでの型付けには以下のようなものがある. 
  \begin{align*}
    A : \ast &\vdash (\lambda x . x) \colon (\Pi x: A .\ \ast) \colon \square \\
    A : \ast,\ P : A \to \ast,\ a : A &\vdash P a : \ast \\
    A : \ast,\ P : A \to \ast &\vdash (\lambda a : A\ \lambda x : P a.\ x) \colon 
      (\Pi a : A .\ (Pa \to Pa))\\
  \end{align*}
\eex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$\lambda$-cube と Curry-Howard同型}
前節で$\lama$の拡張として$\lambda$2と$\lambda$Pを導入したが, これらを組み合わせたものとして$\lambda$P2という$\lambda$計算が存在し, 2階述語論理に相当する表現力を持つ. また, 本論文では触れないが, $\lama$のまた別の拡張として$\lambda \ul{\omega}$というものも存在する(\cite{Bar} Definition 5.1.4, Definition 5.1.5). 
$\lama$を出発点とし, $\lambda$2, $\lambda$P, 
$\lambda \ul{\omega}$の性質を持つかどうかで
8つの$\lambda$計算$\lama$, $\lambda$2, $\lambda \ul{\omega}$, $\lambda \omega$, 
$\lambda$P, $\lambda$P2, $\lambda$P$\ul{\omega}$, $\lambda$P$\omega$
を考えることができ, この8つは以下のように cube を形づくる. 
\[
  \xymatrix{
  & \lambda \omega  \ar[rr] & & \lambda \text{P} \omega \\
  \lambda 2 \ar[ru] \ar[rr] & & \lambda \text{P} 2 \ar[ru] & \\
  & \lambda \ul{\omega} \ar[uu]|\hole \ar[rr]|(.48)\hole& &
    \lambda \text{P} \ul{\omega} \ar[uu] \\
  \lama \ar[uu] \ar[ru] \ar[rr] & & \lambda \text{P} \ar[uu] \ar[ru] &
  }
\]
ここで, 各辺となっている$\longrightarrow$は$\lambda$2, $\lambda \ul{\omega}$, $\lambda$Pのいずれかの性質の導入を表し, 下から上への矢印は$\lambda$2の導入を, 左下から右上への矢印は$\lambda \ul{\omega}$の導入を, 左から右への矢印は$\lambda$Pの導入を表す. 

型付き$\lambda$計算と証明の形式化をつなぐのが, Curry-Howard 同型と呼ばれる, 
\begin{align*}
  \text{命題} &\leftrightarrow \text{型} \\
  \text{証明} &\leftrightarrow \text{型の要素}
\end{align*}
という対応関係である. $\lambda$Pの説明の際にも触れたが, この対応関係を基に命題の証明をシミュレートすることが形式化であり, Coq に型付き$\lambda$計算が関係する理由である. 
\bex 命題$P$, $Q$について, $P \Lra Q$かつ$P$であれば, $Q$が成り立つというモーダスポーネンスの証明をこの同型をもとに考えてみることにする. 論理演算子と型の間にも対応があり, $\Lra$に対応するのは$\lama$で見た関数型$\to$であるため, モーダスポーネンスを証明するには, 
\begin{center}
「$P$という型の要素と$P \to Q$という型の要素から$Q$という型の要素を構成すればよい」
\end{center}
と考えることができる. ここで$P$の要素に$a$, 関数型$P \to Q$の要素(つまり関数)に$f$と名前をつけたとすると, $f$に$a$を適用した$f a$にはどんな型がつくであろうか. $\lama$の導出規則を思い出してみると, ($\to$除去)が使えて$f a$には$Q$という型がつく. よって型として$Q$を持つような要素として具体的に$f a$という項が構成できたため, $Q$が成り立つことを証明できたことになる. 
\eex
論理演算子と型の対応をまとめると以下のようになる. 
\begin{align*}
  P \text{ならば} Q &\quad \text{関数型}P \rightarrow Q \\
  P \text{かつ} Q &\quad \text{直積型}P \times Q \\
  P \text{または} Q &\quad  \text{直和型}P + Q \\
  \text{ある} x \in A \text{について} P(x) &\quad \text{依存和型}\sum_{x : A} P (x)\\
  \text{任意の} x \in A \text{について} P(x) &\quad \text{依存関数型}\prod_{x : A} P (x)
\end{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coq} \label{sec coq}
前節で述べた$\lambda$-cube のうち, 最も強い$\lambda$P$\omega$に帰納的型を導入した$\lambda$計算が Coq で採用されている. 
本節では定理証明支援系 Coq の使い方を具体例を用いて説明し, また, この後の形式化でよく使う型についてその構造の説明も行う.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Coqの使い方} \label{ssec coq_use}
この節ではCoqのコマンドとタクティックの使い方について述べる. ただし, タクティックは証明の中でコンテクスト(変数や仮定)やゴール(証明すべき主張)を変形させるもの, コマンドはタクティック以外のものとする. 
まず, よく使うコマンドについて説明する. 
\begin{description}
  \item[\tt Require Import]
    ライブラリを読み込むためのコマンドである.
    {\tt From mathcomp Require Import ssreflect}
    であれば, ライブラリ群 mathcomp から ssreflect を読み込んでいる.
  \item[\tt Section / End]
    {\tt Section [セクション名]}, {\tt End [セクション名]}でセクションを作ることができ, 
    そのセクション内共通のコンテキストを宣言できる. 
  \item[\tt Variable]
    {\tt Variable [変数]$\colon$[型]}で, 特定の型を持つ変数を宣言できる. 例えば
    
    {\tt Variable n$\colon$nat}
    
    で, 変数{\tt n}が自然数型{\tt nat}の要素であることを表している. 
    {\tt Section/End}コマンドと組み合わせることで, {\tt End}まで同じ意味で扱われ, 
    {\tt End}以降は効力を失う. 
    同時に複数の変数を宣言することもできる. その場合は
    
    {\tt Variables [変数] [変数] $\cdots$ [変数]$\colon$[型]}
    
    と書く(ただし, Coq にとっては{Variable}と{Variables}に違いは無い).    
  \item[\tt Hypothesis]
    {\tt Hypothesis [仮定名]$\colon$[仮定]}で仮定を置くことができる. {\tt Variable}同様, 
    {\tt Section/End}と組み合わせることで, セクション内共通の仮定を置くことができる. 
  \item[\tt Definition]
    新たに関数を定義するためのコマンドで,
    
    {\tt Definition [関数名] ([引数]$\colon$[引数の型])$\colon$[関数の型] := 
    [関数の定義式]}
    
    という形で用いる. 
    \begin{lstlisting}{Coq}
Definition dq (f : R -> R) x := f (q * x) - f x. \end{lstlisting}
    であれば, {\tt dq}が定義の名前, {\tt f}, {\tt x}が引数, {\tt R -> R}が{\tt f}の型であり, 
    {\tt f (q * x) - f x}が{\tt dq}を定義する式である. また, {\tt x}と{\tt dq}そのものの型は
    推論できるため省略できる. 
  \item[\tt Fixpoint]
    再帰関数を定義するためのコマンドで, 
    
    {\tt Fixpoint [関数名] ([引数]$\colon$[引数の型])$\colon$[関数の型] := 
    [定義中の関数を含む定義式]}
    
    と書く. 停止しない関数を認めてしまうと矛盾が生じるため, 停止性が保証されていない
    関数を定義することはできない. 
  \item[\tt Lemma]
    補題を宣言するためのコマンドで,
    
    {\tt Lemma [補題名] ([引数]$\colon$[引数の型])$\colon$[補題の主張]}
    
    という形である. 
    \begin{lstlisting}{Coq}
Lemma Dq_pow n x : x != 0 -> Dq (fun x => x ^ n) x = qnat n * x ^ (n - 1). \end{lstlisting}
    であれば, {\tt Dq\_pow}が補題名, {\tt n}, {\tt x}が引数, {\tt :}以降が補題の主張である. 
    
    {\tt Lemma}の代わりに{\tt Theorem}, {\tt Corollary}等でも同じ機能をもつ. 
  \item[\tt Proof/Qed]
    {\tt Proof}は{\tt Lemma}の後に書いて補題の主張と証明を分ける(実際には省略可能で, 
    人間の見やすさのために書いている). 
    証明を完了させて{\tt Qed}を書くことで Coq に補題を登録することができ, 他の補題の
    証明に使えるようになる. 
\end{description}
次にタクティックについて述べる. タクティックは{\tt Proof...Qed}の間に使われる. よく使われるタクティックは{\tt move}, {\tt apply}, {\tt rewrite}の3つである. 
\begin{description}
  \item[\tt move]
    {\tt move=> H}でゴールの前提に{\tt H}という名前をつけてコンテクストに移動する. 
    また{\tt move$\colon$H}で補題{\tt H}もしくはコンテクストに存在する{\tt H}をゴールの
    前提に移す. 
  \item[\tt apply]
    補題{\it lem}が{\tt P1 $\to$ P2}という形で, ゴールが{\tt P2}のとき, 
    {\tt apply {\it lem}}でゴールを{\tt P1}に変える. 
    コンテクストの仮定{\tt H}が{\tt P1 $\to P2$}であれば{\tt apply H}で同じことができる. 
  \item[\tt rewrite]
    {\it def}が定義のとき, {\tt rewrite /{\it def}}でゴールに出現している{\it def}を展開する. 
    
    また, 補題{\it lem}が{\tt A = B}という形のとき, {\tt rewrite {\it lem}}でゴールに出現する
    {\tt A}を{\tt B}に書き換える(ただし, {\it lem}が{\tt H $\to$ (A = B)}という形であるとき, 
    新たなゴールとして{\tt H}が追加される). 更に, {\tt rewrite {\it lem} in H}で, コンテクストの{\tt H}に
    出現する{\tt A}を{\tt B}に書き換える. {\tt apply}と同じく, 使いたい等式が仮定にある場合も
    同じように使える. 更に, {\tt rewrite}は繰り返し回数や適用箇所を指定できる.
    \begin{description}
      \item[\tt rewrite !{\it lem}] {\it lem}による書き換えを可能な限り繰り返す. 
        ただし場合によっては繰り返しが終わらないことに注意
        ($x + y$を$y + x$に書き換える補題を使う場合など).
      \item[\tt rewrite n!{\it lem}] {\it lem}による書き換えを$n$回限り繰り返す.
      \item[\tt rewrite ?{\it lem}] {\it lem}による書き換えを$0$回または$1$回行う. 
        直前のタクティックでゴールが増える場合に特に有効. 
      \item[\tt rewrite -{\it lem}] 逆向きに{\it lem}による書き換えを行う. 
        つまり, {\it lem}が{\tt A = B}のとき, ゴールの{\tt B}を{\tt A}に書き換える. 
      \item[\tt rewrite \{n\}{\it lem}] {\it lem}で書き換えられる場所のうち
        $n$番目のみを書き換える. 
      \item[{\tt rewrite [条件] {\it lem}}] 条件に一致する場所を{\it lem}で書き換える.
      \item[\tt rewrite (\_ : A = B)] ゴールの{\tt A}を{\tt B}に書き換える. 
        {\tt A = B}がゴールに追加される. この書き方の場合は補題を引数にとらない. 
    \end{description}
    このような, タクティックの前後に書いてその機能を拡張するものをタクティカルと言う. 
    {\tt move=>}の{\tt =>}や{\tt move$\colon$}の{\tt $\colon$}もタクティカルである. 
\end{description}
以下, 2つの具体例を用いて{\tt Proof}内でのタクティックの使い方を説明する. 
\bex{モーダスポーネンス}

Curry-Howard 同型の際にも見たモーダスポーネンスをCoqで証明する. 
まずこの主張を形式化すると以下の通り. 
\begin{lstlisting}{Coq}
From mathcomp Require Import ssreflect.

Lemma modus_ponens (P Q : Prop) : (P -> Q) /\ P -> Q. \end{lstlisting}
{\tt Prop}とは Coq において命題全体を表す型であり, {\tt $\wedge$}は「かつ」を表している. 

このとき, Coqのゴールエリア(コンテクストとゴールが表示される画面)は以下の通りである. 
\begin{screen}
  \begin{lstlisting}{Coq}
    1 subgoal
    P, Q : Prop
    -------------------------------
    (P -> Q) /\ P -> Q \end{lstlisting}
\end{screen}
{\tt ---}の上がコンテクスト, 下がゴ－ルである. 1行目の{1 subgoal}はゴールが1つであることを示しており, 用いるタクティックによってはゴールが増えることもある. 
命題$P_1$, $P_2$, $P_3$について$P_1 \wedge P_2 \to P_3$と$P_1 \to P_2 \to P_3$は同じ意味であり, この書き換えは{\tt move=> []}で行える. 実行すると以下のようにゴールエリアが変化する. 
\begin{screen}
  \begin{lstlisting}{Coq}
    1 subgoal
    P, Q : Prop
    -------------------------------
    (P -> Q) -> P -> Q \end{lstlisting}
\end{screen}
ゴールに前提{\tt (P $\to$ Q)}があるため, {\tt move=> pq}で{\tt pq}という名前をつけてコンテクストに移動する. 
\begin{screen}
  \begin{lstlisting}{Coq}
    1 subgoal
    P, Q : Prop
    pq : P -> Q
    -------------------------------
    P -> Q \end{lstlisting}
\end{screen}
まだ前提{\tt P}があるため, {\tt move=> p}で{\tt p}と名付けてコンテクストに移動する. 
\begin{screen}
  \begin{lstlisting}{Coq}
    1 subgoal
    P, Q : Prop
    pq : P -> Q
    p : P
    -------------------------------
    Q \end{lstlisting}
\end{screen}
ゴールが{\tt Q}であり, コンテクストに{\tt P $\to$ Q}という仮定{\tt pq}があるので, {\tt apply pq}でゴールを{\tt P}に書き換える. 
\begin{screen}
  \begin{lstlisting}{Coq}
    1 subgoal
    P, Q : Prop
    pq : P -> Q
    p : P
    -------------------------------
    P \end{lstlisting}
\end{screen}
ここまで来ると, ゴールが{\tt P}であり, コンテクストに{\tt P}があるため, {\tt by []}で証明を終了する. {\tt done}も{\tt by []}と同じ意味を持つ.
\begin{screen}
  \begin{lstlisting}{Coq}
  No more subgoals. \end{lstlisting}
\end{screen}
ゴールエリアに{\tt No more subgoals.}と表示されれば証明は終了であり, {\tt Qed}を書くことで補題として登録されることになる. 

以上をまとめると次のようになる. 
\begin{lstlisting}{Coq}
Lemma modus_ponens (P Q : Prop) : (P -> Q) /\ P -> Q.
Proof.
  move=> [].
  move=> pq.
  move=> p.
  apply pq.
  by [].
Qed. \end{lstlisting}
説明のため細かく1行づつ書いたが, 複数の{\tt move}はまとめられること, あるタクティックによりゴールが自明なもの(コンテクストに存在する, {\tt A = A}である, 計算から簡単に示されるなど)になる場合はそのタクティックの前に{\tt by}をつけることで証明を終了させられることを用いれば, 次のように短くすることができる. 
\begin{lstlisting}{Coq}
Lemma modus_ponens (P Q : Prop) : (P -> Q) /\ P -> Q.
Proof.
  move=> [] pq p.
  by apply pq.
Qed. \end{lstlisting}
\eex
\bex{代入計算}

自然数$m$, $n$について, 
\[
  m = 0 \Lra n + m = n
\]
という簡単な代入に関する計算を証明してみる. まず主張を形式化する.  
\begin{lstlisting}{Coq}
Lemma substitution m n : m = 0 -> n + m = n. \end{lstlisting}
このとき, ゴールエリアは以下の通りである. 
\begin{screen}
  \begin{lstlisting}{Coq}
    1 subgoal
    m, n : nat
    -------------------------------
    m = 0 -> n + m = n \end{lstlisting}
\end{screen}
まず{\tt m = 0}という前提を{\tt move=> Hm}で{\tt Hm}という名前をつけてコンテクストに移動する. 
\begin{screen}
  \begin{lstlisting}{Coq}
    1 subgoal
    m, n : nat
    Hm : m = 0
    -------------------------------
    n + m = 0 \end{lstlisting}
\end{screen}
仮定に{\tt m = 0}という等式があるため, {\tt rewrite Hm}でゴールの{\tt m}を{\tt 0}に書き換える. 
\begin{screen}
  \begin{lstlisting}{Coq}
    1 subgoal
    m, n : nat
    Hm : m = 0
    -------------------------------
    n + 0 = n \end{lstlisting}
\end{screen}
次に, {\tt n + 0}を{\tt n}に書き換えたい. mathcomp の ssrnat に{\tt addn0}という, 

{\tt forall n : nat, n + 0 = n}

に対応する補題があるため, {\tt rewrite addn0}を実行する. 
\begin{screen}
  \begin{lstlisting}{Coq}
    1 subgoal
    m, n : nat
    Hm : m = 0
    -------------------------------
    n = n \end{lstlisting}
\end{screen}
このとき, ゴールは同じもの同士の等号であるため, 自明に成り立つ, つまり{\tt by []}(もしくは{\tt done})で終了する. 
\begin{screen}
  \begin{lstlisting}{Coq}
    No more subgoals.  \end{lstlisting}
\end{screen}
この証明をまとめると以下の通りである. 
\begin{lstlisting}{Coq}
Lemma substitution m n : m = 0 -> n + m = n.
Proof.
  move=> Hm.
  rewrite Hm.
  rewrite addn0.
  by [].
Qed. \end{lstlisting}
複数の{\tt rewrite}がまとめられることと{\tt by}の使い方から, より短く次のように書ける. 
\begin{lstlisting}{Coq}
Lemma substitution m n : m = 0 -> n + m = n.
Proof.
  move=> Hm.
  by rewrite Hm addn0.
Qed. \end{lstlisting}
更に, 前提が{\tt A = B}の形であるとき, {\tt move$\to$}でゴールの{\tt A}を{\tt B}に書き換えられること, {\tt ;}で異なるタクティックをつなげられることを用いれば以下のように書くこともでできる. 
\begin{lstlisting}{Coq}
Lemma substitution m n : m = 0 -> n + m = n.
Proof. by move->; rewrite addn0. Qed. \end{lstlisting}
\eex
\brmk
  正確には, {\tt addn0}は
  \begin{lstlisting}{Coq}
right_id 0 addn \end{lstlisting}
  という補題であり, {\tt addn}は自然数同士の加法である.  
  {\tt right\_id}の定義は
  \begin{lstlisting}{Coq}
fun (S T : Type) (e : T) (op : S -> T -> S) => forall x : S, op x e = x \end{lstlisting}
  であり, 単位元を右から作用させても元のままであるということを一般的に定義している. 
  {\tt addn0}は{\tt right\_id}の{\tt e}に{\tt 0}を, {\tt op}に{\tt addn}を入れたものであるので,
  \begin{lstlisting}{Coq}
forall x : nat, addn x 0 = x \end{lstlisting}
  となる. 
\ermk
このように, Coqでの証明は, ゴールを自明な形になるまで繰り返し書き変えていくやり方が基本である. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{mathcomp の型}
本節では, 今回の形式化においてよく用いる型, {\tt rcfType}, {\tt nat}, {\tt int}について説明する. 
\subsubsection*{\tt rcfType}
本論文では 実数の形式化としてmathcomp の ssrnum にある{\tt rcfType}を用いることにする. {\tt rcf}とはreal closed field, つまり実閉体の意味であり, {\tt rcfType}とは実閉体全体を表す型のことである. よって, この型そのものではなくこの型の要素を実数として形式化に用いる. 実際の形式化では
\begin{lstlisting}{Coq}
Variable (R : rcfType) (q : R). \end{lstlisting}
としており, {\tt R}が{\tt rcfType}の要素であること, {\tt q}が{\tt R}の要素であることを宣言している. このとき{\tt R}は具体的な型ではなく, 実閉体としての性質をもつ抽象的な型変数を1つ固定したものとして扱っている.

mathcomp はある型を構成するために他の型を用いているため, ヒエラルキー(階層構造)がある. 通常の数学において体が環の性質を, 環が群の性質を引き継ぐように, mathcomp でもより一般の型の性質を引き継いでいる. {\tt rcfType}のヒエラルキーは
\begin{align*}
  {\tt eqType} &\to {\tt choiceType} \\
                   &\to {\tt zmodType} \to {\tt ringType} \to 
                          {\tt comRingType} \to {\tt comUnitRingType} \to 
                          {\tt idomainType} \to {\tt fieldType}\\
                   &\to {\tt numFieldType} \to {\tt realFieldType} \to {\tt rcfType}
\end{align*}
となっており, 多くの性質を引き継いでいる. 特にCoqでの環全体を表す型{\tt ringType}の性質を持っていることが重要で, 実際, 形式化で利用するライブラリの補題の多くは{\tt ringType}に対するものである.
\subsubsection*{\tt nat}
自然数を表す型は{\tt nat}であり, 以下のように帰納的に定義されている. 
\begin{lstlisting}{Coq}
Inductive nat : Set :=  O : nat | S : nat -> nat. \end{lstlisting}
このコードの意味を大まかに説明すると, {\tt nat}という型は{\tt O}という要素と, {\tt nat}の要素から新しく{\tt nat}の要素を作る操作{\tt S}で定義されており, またこれ以外には{\tt nat}の要素がないということである. よって, {\tt O}, {\tt SO}, {\tt S(SO)}などが{\tt nat}の要素である. 
{\tt O}は$0$に対応し(したがって Coq での自然数は$0$を含んでいる), {\tt S}は次の数を作る操作, つまり$+1$に対応するため, {\tt O}, {\tt S O}, {\tt S (S O)}はそれぞれ$0$, $1$, $2$のことである. また, 今後形式化で登場する{\tt .+1}という記号は{\tt S}の別表記であり, 
{\tt n$\colon$nat}に対して{\tt n.+1}は{\tt S n}と同じ意味である. 

帰納的に定義された型の特徴は場合分けが行えることであり, {\tt nat}であれば{\tt n = O}のときと{\tt n = S n0}の場合, つまり$0$かある数の$+1$であるかの場合分けができる. また, {\tt nat}に対しては数学的帰納法を用いることもできる.
\brmk
  証明中で場合分けをしたいときに対応する Coq のタクティックは{\tt case}であり, 
  定義などに使いたい場合は  {\tt match with}等の構文が用意されている. 
  帰納法に対応するタクティックは{\tt elim}である. 
\ermk
\subsubsection*{\tt int}
整数の形式化には{\tt int}という型を利用している. こちらは以下のように定義されている. 
\begin{lstlisting}{Coq}
Variant int : Set :=  Posz : nat -> int | Negz : nat -> int. \end{lstlisting}
{\tt nat}を用いており, {\tt Posz}は自然数から$0$以上の整数に送る関数, {\tt Negz}は自然数から負の整数に送る関数であり, {\tt Negz n = - (Posz n.+1)}という関係がある. 

{\tt int}に対しても場合分けができ, {\tt n : int}とすれば, {\tt n = Posz n0}のときと{\tt n = Negz n0}のとき, すなわち0以上か負かでの場合分けが行える. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{形式化}\label{sec form}
本節から実際に$q$-類似の形式化を行っていく. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$q$-微分の定義}
様々な$q$-類似を考えるにあたって, まずは微分の$q$-類似から始める. 以下, $q$を$1$でない実数とする. 
\bdf[\cite{Kac} p1 (1.1), p2 (1.5)]
  関数$f : \R \to \R$に対して, $f(x)$の$q$差分$d_q f(x)$を, 
  \[
    d_q f(x) \coloneqq f (qx) - f(x)
  \]
  と定める. 更に, $f(x)$の$q$微分を$D_q f(x)$を, 
  \[
    D_q f(x) \coloneqq \frac{d_q f(x)}{d_q x} = \frac{f(qx) - f(x)}{(q - 1) x}
  \]
  と定める. 
\edf
{\tt rcfType}を使って$q$-微分の形式化を以下のように行う. 
\begin{lstlisting}{Coq}
From mathcomp Require Import all_ssreflect all_algebra.
Import GRing.

Section q_analogue.
Local Open Scope ring_scope.
Variables (R : rcfType) (q : R).
Hypothesis Hq : q - 1 != 0.

Notation "f // g" := (fun x => f x / g x) (at level 40).

Definition dq (f : R -> R) x := f (q * x) - f x.
Definition Dq f := dq f // dq id. \end{lstlisting}
2行目の{\tt Import GRing}は{\tt ringType}に対する補題を使いやすくするためのコマンドで, 
7行目の{\tt Notation}は記法を定めるためのコマンドである. 今回であれば関数同士の割り算の記法を定義している. また, {\tt Dq}の定義の中の{\tt id}は恒等関数のことである. 
\brmk
  $f$が微分可能であるとき, 
  \[
    \lim_{q\ra1} D_qf(x) = \frac{d}{dx}f(x)
  \] 
  が成り立つが, 本論文においては極限操作に関しての形式化は扱わない. 
\ermk
次に, $x ^ n$ ($n \in \Z_{\ge 0}$)を$q$-微分した際にうまく振る舞うように自然数の$q$-類似を定義する. 
\bdf[\cite{Kac} p2 (1.9)]
  $n \in \Z_{\ge 0}$に対して, $n$の$q$-類似$[n]$を, 
  \[
    [n] \coloneqq \frac{q^n - 1}{q - 1}
  \]
  と定義する. 
\edf
この$[n]$に対して, $(x^n)' = n x^{n-1}$の$q$-類似が成り立つ.
\bprop[\cite{Kac} p2 Example (1.7)]
  $n \in \Z_{>0}$について, 
  \[
    D_q x^n = [n] x ^{n - 1}
  \]
  が成り立つ. 
\eprop
\bpf
  定義に従って計算すればよく, 
  \[
    D_q x ^ n = \frac{(qx) ^ n - x ^ n}{(q - 1) x}
                 = \frac{q^n - 1}{q - 1} x ^ {n - 1}
                 = [n] x ^ {n - 1}
  \] 
\epf
この定義と補題の形式化は以下の通りである. 
\begin{lstlisting}{Coq}
Definition qnat n : R := (q ^ n - 1) / (q - 1).

Lemma Dq_pow n x : x != 0 -> Dq (fun x => x ^ n) x = qnat n * x ^ (n - 1).
Proof.
  move=> Hx.
  rewrite /Dq /dq /qnat.
  rewrite -{4}(mul1r x) -mulrBl expfzMl -add_div; last by apply mulf_neq0.
  rewrite [in x ^ n](_ : n = (n -1) +1) //; last by rewrite subrK.
  rewrite expfzDr ?expr1z ?mulrA -?mulNr ?red_frac_r ?add_div //.
  rewrite -{2}[x ^ (n - 1)]mul1r -mulrBl mulrC mulrA.
  by rewrite [in (q - 1)^-1 * (q ^ n - 1)] mulrC.
Qed.
\end{lstlisting}
この形式化についていくつか説明を加える. まず用いているタクティックを見てみると, {\tt x $\neq$ 0}という前提があるため, {\tt move=> Hx}で名前をつけてコンテクストに読み込んでいる. その後は基本的に{\tt rewrite}しか用いていないため, 式変形を行っているだけである. また, 証明中3, 4行目の{\tt last}は証明するゴールの順番を入れ替えるタクティックであり, 5行目最後の{\tt //}は{\tt rewrite}の後や{\tt move}, {\tt apply}の後で{\tt => //}という形で用いるタクティカルで, すべてのゴールに対して{\tt done}を試みる機能を持つ({\tt done}が適用できないゴールがあってもエラーにならない). 同じような形で用いるタクティカルに{\tt /=}があり, こちらは定義を開く程度の簡単な計算を試みるものである. この二つを合わせて{\tt //=}とすることもできる. 

証明で用いている補題について, 例えば{\tt mul1r}は
\begin{lstlisting}{Coq}
forall R : ringType, right_id 1  *%R
\end{lstlisting}
という補題であり, 任意の{\tt ringType}を型にもつ{\tt R}について, {\tt R}上の単位元の性質を表している. ここで, 補題の{\tt R}の型は{\tt rcfType}ではなく{\tt ringType}であるが, 前述の通り{\tt rcfType}は{\tt ringType}の性質を持っているため, 今回の形式化に用いている{\tt rcfType}型の{\tt R}についてもこの補題を使うことができる. 補題名{\tt mul1r}の{\tt r}は{\tt ringType}に対する補題であることを表しており, {\tt mulrBl}, {\tt subrK}, {\tt mulrC}なども同じである. 

また{\tt red\_frac\_r}は, 
\begin{lstlisting}{Coq}
forall x y z : R, z != 0 -> (x * z) / (y * z) = x / y \end{lstlisting}
という自分で用意した補題である. この補題の本質は$z / z = 1$という約分計算であり, mathcomp の ssralg の補題
\begin{lstlisting}{Coq}
divff : forall (F : fieldType) (x : F), x != 0 -> x / x = 1 \end{lstlisting}
を用いているため{\tt z $\neq$ 0}という仮定が必要になる. よって, {\tt Dq\_pow}にも{\tt $x \ne 0$}という前提を加えている. 今後も補題を形式化するにあたって, その証明の中で約分を行う際には$0$でないという前提を付け加えることになる. 
\brmk
  {\tt qnat}という名前であるが, 実際には{\tt n}の型は{\tt nat}ではなく{\tt int}にしている. 
  また, {\tt Dq\_of\_pow}の{\tt n}の型は{\tt int}であるため, より一般化した形での形式化に
  なっている. 
\ermk
文献\cite{Kac}では証明は1行で終わっているが, 形式化する場合には何倍もかかっている. これは, 積の交換法則や指数法則などの, 通常の数学では当たり前なことが自動では計算されず, {\tt rewrite mulrC}や{\tt rewrite expfzDr}というように{\tt rewrite}での書き換えを明示的に行わなければならないからである. 一般に, もとの数学の証明と比べてその形式化の方が長くなる. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$(x - a)^n$の$q$-類似}
続いて$(x - a)^n$の$q$-類似を定義し, その性質を調べる.  
\bdf[\cite{Kac} p8 Definition (3.4)]
  $x$, $a \in \R$, $n \in \Z_{\ge 0}$に対して, $(x - a)^n$の$q$-類似$(x - a)^n_q$を, 
  \[
  (x - a)^n_q = \begin{cases}
                      1 & \text{if}\ n = 0 \\
                      (x - a) (x - qa) \cdots (x - q^{n - 1} a) & \text{if}\ n \ge 1
                    \end{cases}
  \]
  と定義する. 
\edf
\bprop \label{Dq_qbinom_nonneg}
  $n\in\Z_{>0}$に対し, 
  \[
    D_q(x-a)^n_q = [n](x-a)^{n-1}_q
  \]
  が成り立つ. 
\eprop
\bpf
  $n$についての帰納法により示される. 
\epf
まず, $(x - a)^n_q$の定義を形式化する. 
\begin{lstlisting}{Coq}
Fixpoint qbinom_pos a n x :=
  match n with
  | 0 => 1
  | n0.+1 => (qbinom_pos a n0 x) * (x - q ^ n0 * a)
  end. \end{lstlisting}
{\tt Fixpoint}を用いて再帰的な定義をしており, {\tt match}を使って{\tt n}が{\tt 0}かどうかで場合分けしている. 再帰で呼び出す際に引数{\tt n}が真に小さくなっているため停止性が保証されている. 補題の証明については以下の通り. 
\begin{lstlisting}{Coq}
Theorem Dq_qbinom_pos a n x : x != 0 ->
  Dq (qbinom_pos a n.+1) x =
  qnat n.+1 * qbinom_pos a n x.
Proof.
  move=> Hx.
  elim: n => [|n IH].
  - rewrite /Dq /dq /qbinom_pos /qnat.
    rewrite !mul1r mulr1 expr1z.
    rewrite opprB subrKA !divff //.
    by rewrite denom_is_nonzero.
  - rewrite (_ : Dq (qbinom_pos a n.+2) x =
                 Dq ((qbinom_pos a n.+1) **
                 (fun x => (x - q ^ (n.+1) * a))) x) //.
    rewrite Dq_prod' //.
    rewrite [Dq (+%R^~ (- (q ^ n.+1 * a))) x]/Dq /dq.
    rewrite opprB subrKA divff //; last by apply denom_is_nonzero.
    rewrite mulr1 exprSz.
    rewrite -[q * q ^ n * a]mulrA -(mulrBr q) IH.
    rewrite -[q * (x - q ^ n * a) * (qnat n.+1 * qbinom_pos a n x)]mulrA.
    rewrite [(x - q ^ n * a) * (qnat n.+1 * qbinom_pos a n x)]mulrC.
    rewrite -[qnat n.+1 * qbinom_pos a n x * (x - q ^ n * a)]mulrA.
    rewrite (_ : qbinom_pos a n x * (x - q ^ n * a) = qbinom_pos a n.+1 x) //.
    rewrite mulrA -{1}(mul1r (qbinom_pos a n.+1 x)).
    by rewrite -mulrDl -qnat_cat1.
Qed.
\end{lstlisting}
{\tt elim:\,n}で{\tt n}に対する数学的帰納法をしており, 後はすべて{\tt rewrite}による式変形である. {\tt elim}の直後の{\tt -}はゴールを変形するタクティックではなく, ゴールが増えた際にコードを読みやすくするために入れている記号である. 

指数法則については, 一般には$(x - a)^{m + n} \neq (x - a)^m_q(x - a)^n_q$であり, 以下のようになる. 
\bprop[\cite{Kac} p8 (3.6)] \label{q_exp_low}
  $x,a\in\R$, $m,n\in\Z_{>0}$について, 
  \[
    (x-a)^{m+n}_q = (x-a)^m_q (x-q^ma)^n_q
  \]
  が成り立つ. 
\eprop
\bpf
  \begin{align*}
    (x-a)^{m+n}_q &= (x-a)(x-qa)\cdots(x-q^{m-1}a)
                         \times (x-q^ma)(x-q^{m+1}a)\cdots(x-q^{m+n-1})\\
                       &= (x-a)(x-qa)\cdots(x-q^{m-1}a)
                         \times (x-q^ma)(x-q(q^mx))\cdots(x-q^{n-1}(q^ma))\\
                       &= (x-a)^m_q(x-q^ma)^{n}_q
  \end{align*}
  より成立する.
\epf
この形式化は次の通りである. 
\begin{lstlisting}{Coq}
Lemma qbinom_pos_explaw x a m n :
  qbinom_pos a (m + n) x =
    qbinom_pos a m x * qbinom_pos (q ^ m * a) n x.
Proof.
  elim: n.
  - by rewrite addn0 /= mulr1.
  - elim => [_|n _ IH].
    + by rewrite addnS /= addn0 expr0z !mul1r.
    + rewrite addnS [LHS]/= IH /= !mulrA.
      by rewrite -[q ^ n.+1 * q ^ m] expfz_n0addr // addnC.
Qed.
\end{lstlisting}
\cite{Kac}の証明では単に式変形しているが, 形式化の証明では{\tt m}, {\tt n}に関する帰納法を用いている. これは{\tt qbinom\_pos}が再帰的に定義されているため, $m$項と$n$項で分けるよりも最後の$1$項を取り出す方が簡単であり, 帰納法と相性が良いからである. 

この指数法則を用いて, $(x - a)^n_q$の$n$を負の数に拡張する. まず, \cite{Kac}の定義は
\bdf[\cite{Kac} p9 (3.7)] \label{qbinom_neg}
  $x$, $a \in \R$, $l\in\Z_{>0}$とする. このとき, 
  \[
    (x-a)^{-l}_q \coloneqq \frac{1}{(x-q^{-l}a)^l_q}
  \]
  と定める. 
\edf
であり, この形式化は, 
\begin{lstlisting}{Coq}
Definition qbinom_neg a n x := 1 / qbinom_pos (q ^ ((Negz n) + 1) * a) n x.
\end{lstlisting}
となる. {\tt int}は$0$以上か負かで場合分けできるため, 
{\tt n$\colon$int}に対して{\tt qbinom\_pos}の定義を以下のように整数に拡張する. 
\begin{lstlisting}{Coq}
Definition qbinom a n x :=
  match n with
  | Posz n0 => qbinom_pos a n0 x
  | Negz n0 => qbinom_neg a n0.+1 x
  end.
\end{lstlisting}
整数に拡張した$(x - a)^n_q$についても, 指数法則と$q$-微分はうまく振る舞う.
まず指数法則について見ていく. 
\bprop[\cite{Kac} p10 Proposition 3.2]
  $m$, $n \in \Z$について, Proposition \ref{q_exp_low}は成り立つ, つまり
  \[
    (x - a)^{m + n}_q = (x - a)^m_q (x - q^m a)^n_q
  \]
  が成り立つ. 
\eprop
\bpf
  $m$, $n$の正負で場合分けして示す. $m > 0$かつ$n > 0$の場合はすでに示しており, 
  $m = n =0$の場合は定義からすぐにわかる. その他の場合について, まず$m < 0$かつ
  $n \ge 0$の場合, $m = -m'$とおくと
  \begin{align*}
    (x - a)^m_q (x - q^m)^n_q &= (x - a)^{-m'}_q (x - q^{-m'} a)^n_q\\
                                       &= \frac{(x - q^{-m'} a)^n_q}{(x - q^{-m'} a)^{m'}_q}\\
                                       &= \begin{cases}
                                              (x - q^{m'} (q ^{-m'} a))^{n - m'}_q & n \ge m' \\
                                              \frac{1}{(x - q^n (q ^{-m'} a))^{m' - n}_q} & n < m'
                                            \end{cases}\\
												 &= (x - a)^{n - m'}_q\\
												 &= (x - a)^{n + m}_q
  \end{align*}
  というように, $n$と$m'$の大小で場合分けすることで示せる. 次に, $m \ge 0$かつ$n < 0$
  の場合, $n = - n'$として, 
  \begin{align*}
    (x - a)^m_q (x - q^m)^n_q &= (x - a)^{m}_q (x - q^m a)^{-n'}_q\\
                                       &= \begin{cases}
                                             \frac{(x - a)^{m - n'}_q (x - q^{m - n'} a)^{n'}_q}
                                                    {(x - q^{m - n'} a)^{n'}_q} & m \ge n' \\
                                             \frac{(x - a)^m_q}
                              {(x - q^{m - n'})^{n' - m}_q (x - q^{n' - m}(q^{m - n'}a))^m_q} & m < n      
                                           \end{cases}\\
                                       &= \begin{cases}
                                              (x - a)^{m - n'}_q & m \ge n' \\
                                              \frac{1}{(x - q^{m - n'}a)^{n' - m}_q} & m < n'
                                            \end{cases}\\
                                       &=  (x - a)^{m - n'}_q = (x - a)^{m + n}_q
  \end{align*}
  となる. 最後に, $m < 0$かつ$n < 0$のとき, $m = -m'$, $n = -n'$として, 
  \begin{align*}
    (x - a)^m_q (x - q^m)^n_q &= (x - a)^{-m'}_q (x - q^{-m'})^{-n'}_q\\
                                       &= \frac{1}{(x - q^{-m'} a)^{m'}_q (x - q^{-n'-m'}a)^{n'}_q}\\
                              &= \frac{1}{(x - q^{-n'-m'}a)^{n'}_q (x - q^{n'}(q^{-m'-n'} a))^{m'}_q }\\
                                       &= \frac{1}{(x - q^{-n'-m'} a)^{n' + m'}_q}\\
                                       &= (x - a)^{-m'-n'}_q\\
                                       &= (x - a)^{m + n}_q
  \end{align*}
  となる.
\epf
この補題を形式化すると次のようになる. 
\begin{lstlisting}{Coq}
Theorem qbinom_explaw a m n x : q != 0 ->
  qbinom_denom a m x != 0 ->
  qbinom_denom (q ^ m * a) n x != 0 ->
  qbinom a (m + n) x = qbinom a m x * qbinom (q ^ m * a) n x.
Proof.
  move=> Hq0.
  case: m => m Hm.
  - case: n => n Hn.
    + by apply qbinom_pos_explaw.
    + rewrite qbinom_exp_pos_neg //.
      by rewrite addrC expfzDr // -mulrA.
  - case: n => n Hn.
    + by rewrite qbinom_exp_neg_pos.
    + by apply qbinom_exp_neg_neg.
Qed.
\end{lstlisting}
証明の構造としては, まず{\tt case$\colon$m}で{\tt m}が$0$以上か負かの場合分けを行い, 更にそれぞれの場合について{\tt case:n}で{\tt n}の場合分けを行っている. 
ここで, 前提の{\tt qbinom\_denom}の定義は
\begin{lstlisting}{Coq}
Definition qbinom_denom a n x :=
 match n with
  | Posz n0 => 1
  | Negz n0 => qbinom_pos (q ^ Negz n0 * a) n0.+1 x
  end. \end{lstlisting}
であり, 2つの前提は補題の右辺に出現する項の分母が$0$にならないということである. 
証明中に使われている補題のうち, {\tt qbinom\_exp\_pos\_neg}, {\tt qbinom\_exp\_neg\_pos}, {\tt qbinom\_exp\_neg\_neg}はそれぞれ$m \ge 0$かつ$n < 0$, $m <0$かつ$n \ge 0$, $m < 0$かつ$n < 0$のときの証明の形式化であり, 例えば{\tt qbinom\_exp\_pos\_neg}については以下の通り. 
\begin{lstlisting}{Coq}
Lemma qbinom_exp_pos_neg a (m n : nat) x : q != 0 ->
  qbinom_pos (q ^ (Posz m + Negz n) * a) n.+1 x != 0 ->
  qbinom a (Posz m + Negz n) x = qbinom a m x * qbinom (q ^ m * a) (Negz n) x.
Proof.
  move=> Hq0 Hqbinommn.
  case Hmn : (Posz m + Negz n) => [l|l]  /=.
  - rewrite /qbinom_neg mul1r.
    rewrite (_ : qbinom_pos a m x = qbinom_pos a (l + n.+1) x).
      rewrite qbinom_pos_explaw.
      have -> : q ^ (Negz n.+1 + 1) * (q ^ m * a) = q ^ l * a.
        by rewrite mulrA -expfzDr // -addn1 Negz_addK addrC Hmn.
      rewrite -{2}(mul1r (qbinom_pos (q ^ l * a) n.+1 x)) red_frac_r.
        by rewrite divr1.
      by rewrite -Hmn.
    apply Negz_transp in Hmn.
    apply (eq_int_to_nat R) in Hmn.
    by rewrite Hmn.
  - rewrite /qbinom_neg.
    have Hmn' : n.+1 = (l.+1 + m)%N.
      move /Negz_transp /esym in Hmn.
      rewrite addrC in Hmn.
      move /Negz_transp /(eq_int_to_nat R) in Hmn.
      by rewrite addnC in Hmn.
    rewrite (_ : qbinom_pos (q ^ (Negz n.+1 + 1) * (q ^ m * a)) n.+1 x 
               = qbinom_pos (q ^ (Negz n.+1 + 1) * (q ^ m * a))
                              (l.+1 + m) x).
      rewrite qbinom_pos_explaw.
      have -> : q ^ (Negz n.+1 + 1) * (q ^ m * a) =
                q ^ (Negz l.+1 + 1) * a.
        by rewrite mulrA -expfzDr // !NegzS addrC Hmn.
      have -> : q ^ l.+1 * (q ^ (Negz l.+1 + 1) * a) = a.
        by rewrite mulrA -expfzDr // NegzS NegzK expr0z mul1r.
      rewrite mulrA.
      rewrite [qbinom_pos (q ^ (Negz l.+1 + 1) * a) l.+1 x *
               qbinom_pos a m x]mulrC.
      rewrite red_frac_l //.
      have -> : a = q ^ l.+1 * (q ^ (Posz m + Negz n) * a) => //.
        by rewrite mulrA -expfzDr // Hmn NegzK expr0z mul1r.
      apply qbinom_exp_non0r.
      rewrite -Hmn' //.
    by rewrite Hmn'.
Qed.
\end{lstlisting}
この証明についての注目点としては, 
\begin{itemize}
  \item \cite{Kac}では$m$と$n'$の大小で場合分けをしていたが, 形式化では, 
           \begin{lstlisting}{Coq}
  case Hmn : (Posz m + Negz n) => [l|l]  /=. \end{lstlisting}
           として, {\tt m $-$ n'}の値を{\tt l}とおき, {\tt l}が{\tt 0}以上かどうかで
           場合分けをしている. 
  \item {\tt have}は仮定を追加するためのタクティックで, 
  
    {\tt have H$\colon$P}
    
    と書くことで{\tt P}がゴールに追加され, その証明が終わればコンテクストに{\tt P}が追加される. 
    また, 
    
    {\tt have $\to \colon$ A = B}
    
    と書くと{\tt rewrite (\_ : A = B)}とほとんど同じ働きをする. 
  \item Coqでは$A = B$という等式はどの型の上でのものなのかが区別されている. 
           {\tt eq\_int\_to\_nat}という補題は{\tt int}上の等式を{\tt nat}上の等式に写している. 
\end{itemize}
などが挙げられる. 

次に$q$-微分について見ていく.  
\bprop[\cite{Kac} p10 Proposition 3.3]
  $n \in \Z$について, 
  \[
    D_q (x - a)^n_q = [n] (x - a)^{n - 1}_q
  \]
  が成り立つ. ただし, $n$が整数の場合にも, 自然数のときと同様, $[n]$の定義は
  \[
    \frac{q^n - 1}{q - 1}
  \]
  である. 
\eprop
\bpf
  $n > 0$のときは Proposition \ref{Dq_qbinom_nonneg} であり, $n = 0$のときは$[0] = 0$からすぐにわかる. 
  $n < 0$のときは, Definition \ref{qbinom_neg}と, 商の微分公式の$q$-類似版である
  \[
    D_q \left( \frac{f(x)}{g(x)} \right) = \frac{g(x) D_q f(x) - f(x) D_q g(x)}{g(x) g(qx)} \quad
    \text{(\cite{Kac} p3 (1.13))}
  \]
  及び Proposition \ref{Dq_qbinom_nonneg}を用いて示される. 
\epf
\cite{Kac}と同じ方針で証明する. まず, $n = 0$のときは次の通り. 
\begin{lstlisting}{Coq}
Lemma Dq_qbinomn0 a x :
  Dq (qbinom a 0) x = qnat 0 * qbinom a (- 1) x.
Proof. by rewrite Dq_const qnat0 mul0r. Qed. \end{lstlisting}
ここで, {\tt Dq\_const}は
\begin{lstlisting}{Coq}
Lemma Dq_const x c : Dq (fun x => c) x = 0. \end{lstlisting}
という定数関数の$q$-微分は$0$であるという補題である. 次に, $n < 0$のときは以下のようになる. 
\begin{lstlisting}{Coq}
Theorem Dq_qbinom_neg a n x : q != 0 -> x != 0 ->
  (x - q ^ (Negz n) * a) != 0 ->
  qbinom_pos (q ^ (Negz n + 1) * a) n x != 0 ->
  Dq (qbinom_neg a n) x = qnat (Negz n + 1) * qbinom_neg a (n.+1) x.
Proof.
  move=> Hq0 Hx Hqn Hqbinom.
  destruct n.
  - by rewrite /Dq /dq /qbinom_neg /= addrK' qnat0 !mul0r.
  - rewrite Dq_quot //.
      rewrite Dq_const mulr0 mul1r sub0r.
      rewrite Dq_qbinom_pos // qbinom_qx // -mulNr.
      rewrite [qbinom_pos (q ^ (Negz n.+1 + 1) * a) n.+1 x *
                (q ^ n.+1 * qbinom_pos (q ^ (Negz n.+1 + 1 - 1) *
                  a) n.+1 x)] mulrC.
      rewrite -mulf_div.
      have -> : qbinom_pos (q ^ (Negz n.+1 + 1) * a) n x /
                    qbinom_pos (q ^ (Negz n.+1 + 1) * a) n.+1 x =
                      1 / (x - q ^ (- 1) * a).
        rewrite -(mulr1 (qbinom_pos (q ^ (Negz n.+1 + 1) * a) n x)) /=.
        rewrite red_frac_l.
          rewrite NegzE mulrA -expfzDr // addrA -addn2.
          rewrite (_ : Posz (n + 2)%N = Posz n + 2) //.
          by rewrite -{1}(add0r (Posz n)) addrKA.
        by rewrite /=; apply mulnon0 in Hqbinom.
      rewrite mulf_div.
      rewrite -[q ^ n.+1 *
                 qbinom_pos (q ^ (Negz n.+1 + 1 - 1) * a) n.+1 x *
                   (x - q ^ (-1) * a)]mulrA.
      have -> : qbinom_pos (q ^ (Negz n.+1 + 1 - 1) * a) n.+1 x *
                (x - q ^ (-1) * a) =
                qbinom_pos (q ^ (Negz (n.+1)) * a) n.+2 x => /=.
        have -> : Negz n.+1 + 1 - 1 = Negz n.+1.
          by rewrite addrK.
        have -> : q ^ n.+1 * (q ^ Negz n.+1 * a) = q ^ (-1) * a => //.
        rewrite mulrA -expfzDr // NegzE.
        have -> : Posz n.+1 - Posz n.+2 = - 1 => //.
        rewrite -addn1 -[(n + 1).+1]addn1.
        rewrite (_ : Posz (n + 1)%N = Posz n + 1) //.
        rewrite (_ : Posz (n + 1 + 1)%N = Posz n + 1 + 1) //.
        rewrite -(add0r (Posz n + 1)).
        by rewrite addrKA.
      rewrite /qbinom_neg /=.
      rewrite (_ : Negz n.+2 + 1 = Negz n.+1) // -mulf_div.
      congr (_ * _).
      rewrite NegzE mulrC /qnat -mulNr mulrA.
      congr (_ / _).
      rewrite opprB mulrBr mulr1 mulrC divff; last by rewrite expnon0.
      rewrite invr_expz (_ : - Posz n.+2 + 1 = - Posz n.+1) //.
      rewrite -addn1 (_ : Posz (n.+1 + 1)%N = Posz n.+1 + 1) //.
      by rewrite addrC [Posz n.+1 + 1]addrC -{1}(add0r 1) addrKA sub0r.
    rewrite qbinom_qx // mulf_neq0 //.
      by rewrite expnon0.
    rewrite qbinom_pos_head mulf_neq0 //.
    rewrite (_ : Negz n.+1 + 1 - 1 = Negz n.+1) //.
      by rewrite addrK.
    move: Hqbinom => /=.
    move/mulnon0.
    by rewrite addrK mulrA -{2}(expr1z q) -expfzDr.
Qed.\end{lstlisting}
非常に長くなっているが積の交換則や結合則などが多く, {\tt Dq\_quot}が商の$q$-微分公式の形式化であるため, \cite{Kac}の証明をそのまま形式化したものになっている. また, 約分のためいくつかの項が$0$でないという条件がついている. 

これらをまとめて以下のように形式化できる. 
\begin{lstlisting}{Coq}
Theorem Dq_qbinom a n x : q != 0 -> x != 0 ->
  x - q ^ (n - 1) * a != 0 ->
  qbinom (q ^ n * a) (- n) x != 0 ->
  Dq (qbinom a n) x = qnat n * qbinom a (n - 1) x.
Proof.
  move=> Hq0 Hx Hxqa Hqbinom.
  case: n Hxqa Hqbinom => [|/=] n Hxqa Hqbinom.
  - destruct n.
    + by rewrite Dq_qbinomn0.
    + rewrite Dq_qbinom_pos //.
      rewrite (_ : Posz n.+1 - 1 = n) // -addn1.
      by rewrite (_ : Posz (n + 1)%N = Posz n + 1) ?addrK.
  - rewrite Dq_qbinom_int_to_neg Dq_qbinom_neg //.
        rewrite Negz_addK.
        rewrite (_ : (n + 1).+1 = (n + 0).+2) //.
        by rewrite addn0 addn1.
      rewrite (_ : Negz (n + 1) = Negz n - 1) //.
      by apply itransposition; rewrite Negz_addK.
    by rewrite Negz_addK addn1.
Qed.
\end{lstlisting}
{\tt case:\,n}で{\tt n}が$0$以上か負かで場合分けを, {\tt destruct n}で$0$か$1$以上かの場合分けをしており, それぞれの場合で{\tt Dq\_qbinom\_0}, {\tt Dq\_qbinom\_pos}, {\tt Dq\_qbinom\_neg}を使っていることが見て取れる. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{関数から多項式へ} \label{ssec poly}
本節では, 今まで関数として形式化していた$q$-微分や$(x - a)^n_q$を多項式として定義しなおしていく. 多項式として捉えなおす理由は, $q$-Taylor展開が多項式に関する定理であることに加え, 次の2つのメリットがあるからである. 
\begin{description}
\item[$x / x = 1$の計算に$x \neq 0$という条件が必要ない]

  先に見たように, Coqで約分の計算, つまり$x / x = 1$を行う際には$x \ne 0$という条件が
  必要である. よって, 実数$x$対して$x / x = 1$を計算する場合, 後から$x = 0$を代入することは
  できない.   しかし, 多項式で考える場合, $x$は単項式であるためゼロ多項式とは
  異なるので, $x \neq 0$という条件は自動的にみたされることになり, $x / x = 1$
  の計算には特に条件が必要ない. よって, $x$で約分した後でも$0$での値を計算できる.  
  例えば$D_q (x + a)^n_q = [n](x + a)^{n - 1}_q$という計算には$x$での約分が必要であるが, 
  多項式として考える場合には上の計算をした後でも$0$での値を求めることができる. 
  この値は本論文の目的であるGauss's binomial formulaの証明に必要である. 
\item[$q = 0$のとき高階$D_q$が定義できる]

	$q = 0$のときに2階$D_q$を計算してみると
	\begin{align*}
	  (D_q ^2 f) (x) = (D_0 ^2 f) (x) &= (D_0 (D_0 f)) (x) \\
	                    &= D_0 \left( \lambda x.\ \frac{f (0 x) - f(x)}{(0 - 1)x} \right) (x) \\
	                    &= D_0 \left( \lambda x.\ \frac{f(x) - f(0)}{x} \right) (x) \\
	                    &= (D_0 F) (x)
	                      \quad (\text{ここで}F \coloneqq \lambda x.\ \frac{f(x) - f(0)}{x}
	                                \text{とおいた})\\
	                    &= \lambda x.\ \frac{F(x) - F(0)}{x} (x) \\
	                    &= \frac{F(x) - F(0)}{x}
	\end{align*}
	となるが, 
	\[
	  F(0) = \frac{f(0) - f(0)}{0} = \frac{0}{0}
	\]
	となってしまう
	(Coq では$0/0$は$0$と定義されているが, これでも正しい計算結果とはならない).
	この問題が起きるのはもともとの$dq$を関数の引数に対して各点ごとに定義しているから
	であり, 多項式の係数を変化させることで定義すれば$q = 0$でも問題が起きない. 
	よって多項式に対して定義しなおした$q$-微分は$q = 0$かどうかにかかわらず
	高階$q$-微分を定義できる. 
\end{description}
通常の数学では関数と多項式の違いをあまり意識しないことも多く, $(x - a)^n_q$は, \cite{Kac}の定義から多項式になることは当たり前に思えるかもしれないが, Coq では関数と多項式は明確に区別されている. 前節での$(x - a)^n_q$の形式化{\tt qbinom\_pos}は, {\tt R}の要素を受け取って{\tt R}の要素を返す関数として定義されており, Coq では一度関数として定義したものを多項式として扱うことはできない. そのため$(x - a)^n_q$の形式化を多項式として改めて定義し, 前節での定義と一致することを確認するという方法をとることにする. 

また, これまでの$q$-微分の形式化{\tt Dq}は関数の各点での値として定義していたため, 多項式として定義しなおした{qbinom\_pos\_poly}に適用することはできない. そのため$q$-微分の形式化も多項式に対する定義に変えなくてはならない. 
\brmk
  実際には, 多項式$p$に対して$x \mapsto \text{($p$の$x$での値)}$という関数を考えれば
  これまでの{\tt Dq}に適用できる. しかし, 各点での定義のままでは前述のとおり約分を行うために
  $0$でないという条件が必要となり不都合が生じるので, 多項式を受け取り多項式を返す操作
  として定義し直すことにする. 
\ermk
ここで, Coqにおける多項式の扱いについて説明する. 
{\tt \{poly T\}}で{\tt T}係数多項式全体を表す型となる. {\tt T}は{\tt ringType}でなくてはならないが, {\tt rcfType}は{\tt ringType}の構造を引き継いでいるため, 今回用いている{\tt R}に対して{\tt \{poly R\}}が定義できる. 
また, もともと通常の数学において環を係数にもつ多項式全体の集合は環を成し, また加群の構造を持っているが, Coq において多項式全体を表す型{\tt \{poly T\}}も{\tt ringType}と{\tt lmodType}の構造を持っている. よって, 前者の性質から今まで使ってきた{\tt ringType}に対する補題がそのまま使え, 後者からスカラー倍{\tt a *$\colon$p} (ここで{\tt a$\colon$T}, 
{\tt p$\colon$\{poly T\}}である)に関する補題が利用できる. {\tt \{poly\}}に関する記号や操作については以下の通り. 
\begin{description}
  \item[\tt \textbackslash poly\_(i < n) E(i)] 次数が$n - 1$次以下, $i$次の係数が$E(i)$
    である多項式
  \item[\tt c\%:P] 定数$c$のみからなる単項式
  \item[\tt 'X] 変数$x$のみからなる単項式
  \item[\tt p`\_i] 多項式$p$の$i$次の係数 
  \item[\tt size p] 多項式$p$の次数$+1$
    {\tt size}が$0$である多項式はゼロ多項式のみであり, 
    {\tt size}が$1$である多項式は定数項のみからなる式である. 
  \item[{\tt p.[x]}] 多項式$p$の$x$での値 
\end{description}
より詳細な内容については mathcomp の poly.v を参照のこと. 

この{\tt \{poly R\}}を用いて{\tt Dq}や{\tt qbinom}を定義し直していく. 
まず, $q$-微分について, 多項式に対する$d_q$を以下のように定義し直す. 
\begin{lstlisting}{Coq}
Definition scale_var (p : {poly R}):= \poly_(i < size p) (q ^ i * p`_i).
Definition dqp p := scale_var p - p. \end{lstlisting}
{\tt scale\_var}は多項式{\tt p}を受け取り, $i$次の係数を$q^i$倍した多項式を返す操作で, すなわち$x$を$qx$に変えている. また, {\tt dqp}は多項式に対しての{\tt dq}と同じ結果になることが確認できる(正確には, {\tt dqp}を適用した多項式での{\tt x}での値と${\tt x} \mapsto {\tt p.[x]}$という関数に{\tt dq}を適用した関数の{\tt x}での値が等しいということである). 
\begin{lstlisting}{Coq}
Definition ap_op_poly (D : (R -> R) -> (R -> R)) (p : {poly R}) := D (fun (x : R) => p.[x]).
Notation "D # p" := (ap_op_poly D p) (at level 49).
Lemma dqp_dqE p x : (dqp p).[x] = (dq # p) x. \end{lstlisting}
この{\tt dqp}を用いて, 多項式に対する$D_q$を定義する. 
\begin{lstlisting}{Coq}
Definition Dqp p := dqp p %/ dqp 'X.
\end{lstlisting}
{\tt p \%/ p'}は多項式{\tt p}を多項式{\tt p'}で割った商を表している. この定義だけでは
{\tt dqp}を{\tt dq 'X}で割った余りが$0$でない可能性があるため, $q$-微分の正しい形式化である保証がない. しかし実際に多項式に対して{\tt Dqp}を計算すると, {\tt dqp}の定義から, {\tt dqp p}は定数項が打ち消しあい, また{\tt dqp 'X}は{\tt (q - 1) * 'X}となるので割り切れるはずである. 
よってこのことを証明しておく.  
\begin{lstlisting}{Coq}
Lemma Dqp_ok p : dqp 'X %| dqp p.
\end{lstlisting}
ここで, {\tt p' \%| p}で{\tt p}が{\tt p'}で割り切れることを表す. 
\brmk
  mathcomp の fraction.v では整域から構成する商体を形式化している. 
  通常の数学と同様{\tt \{poly R\}}は整域になるため, fraction.v の内容を使って{\tt Dqp}の定義が妥当であることを証明できる. 
  \begin{lstlisting}{Coq}
Import FracField.

Local Notation tofrac := (@tofrac [idomainType of {poly R}]).
Local Notation "x %:F" := (tofrac x).

Theorem Dqp_ok_frac p : (dqp p)%:F / (dqp 'X)%:F = (Dqp p)%:F.
\end{lstlisting}
ここで{\tt x \%:F}は整域の要素{\tt x}を商体の要素{\tt x/1}に送る操作である. 
\ermk
今後は扱いやすさのため, {\tt `X}で約分した形
\begin{lstlisting}{Coq}
Definition Dqp' (p : {poly R}) := \poly_(i < size p) (qnat (i.+1) * p`_i.+1).
\end{lstlisting}
を用いる. このとき, {\tt Dqp}と{\tt Dqp'}が等しいことも示せる. 
\begin{lstlisting}{Coq}
Lemma Dqp_Dqp'E p : Dqp p = Dqp' p. \end{lstlisting}
また, {\tt dqp}のときと同様, 多項式に対しての$D_q$と同じであることを確認しておく. 
\begin{lstlisting}{Coq}
Lemma Dqp'_DqE p x : x != 0 -> (Dqp' p).[x] = (Dq # p) x. \end{lstlisting}
\brmk
  {\tt Dqp\_Dqp'E}には特に条件がなく, {\tt Dqp'\_DqE}には$x \neq 0$という条件がついている. 
  この違いは, 前者は{\tt 'X / 'X = 1\%:P}という多項式での約分を, 後者は{\tt x / x = 1}という
  実数での約分を行っているということから生じている. 前述の通り, 約分の際に条件が
  必要なくなることが多項式で考える利点の一つである. 
\ermk
次に, $(x - a)^n_q$を多項式として以下のように定義しなおす. 
\begin{lstlisting}{Coq}
Fixpoint qbinom_pos_poly a n :=
  match n with
  | 0 => 1
  | n.+1 => (qbinom_pos_poly a n) * ('X - (q ^ n * a)%:P)
  end. \end{lstlisting}
この多項式の{\tt x}での値は元の定義の{\tt qbinom\_pos}と等しくなる. 
\begin{lstlisting}{Coq}
Lemma qbinom_posE a n x :
  qbinom_pos a n x = (qbinom_pos_poly a n).[x].
\end{lstlisting}
更に, このように定義した{\tt Dqp}と{\tt qbinom\_pos\_poly}に対してもProposition \ref{Dq_qbinom_nonneg}と同じことが成り立つ. 
\begin{lstlisting}{Coq}
Lemma Dqp'_qbinom_poly a n :
  Dqp' (qbinom_pos_poly a n.+1) = (qnat n.+1) *: (qbinom_pos_poly a n).
\end{lstlisting}
\brmk
  証明の方針はこれまでの関数としての場合と同じだが, {\tt Dq\_prod'}($q$-微分の積の法則)に
  対応する補題の証明のため, {\tt scale\_var}が積について分解できること, つまり
  \begin{lstlisting}{Coq}
Lemma scale_var_prod (p p' : {poly R}) : scale_var (p * p') = scale_var p * scale_var p'. \end{lstlisting}
  を示している. ここで証明の冒頭を抜き出すと以下のようになっている. 
  \begin{lstlisting}{Coq}
Proof.
  pose n := size p.
  have : (size p <= n)%N by [].
  clearbody n.
  have Hp0 : forall (p : {poly R}), size p = 0%N ->
    scale_var (p * p') = scale_var p * scale_var p'.
    move=> p0 /eqP.
    rewrite size_poly_eq0.
    move/eqP ->.
    by rewrite mul0r scale_varC mul0r.
  elim: n p => [|n IH] p Hsize.
  ...
Qed. \end{lstlisting}
  {\tt pose n := size p.}で多項式{\tt p}の{\tt size}を{\tt n}と置いており, 
  {\tt have$\colon$(size p <= n)\%N by [].}で{\tt size p}が{\tt n}以下という自明な主張を
  あえて置いているが, これは多項式の{\tt size}に関する帰納法を用いるためである. 
  このように, 当たり前の内容を明示的に書かなければならないことに加え, 
  形式化するための証明の構造を工夫しなければならない場合もある. 
\ermk
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$q$-Taylor展開} \label{ssec q_Taylor}
この節では, 本論文の主目的である有限次Taylor展開の$q$-類似が成り立つこと, そしてその系として Gauss's binomial formula が成り立つことを示し, 形式化する. 
まず, 一般に以下のことが成り立つことを確認しておく. 
\bthm[\cite{Kac} p5 Theorem 2.1] \label{general_Taylor}
$\K\coloneqq\R$または$\C$, $V\coloneqq\K[x]$とし, $D$を$V$上の線型作用素とする. また, 
$\{P_n(x)\}_{n=0}\subset V$ ($n=0,1,2,\cdots$)は次の三条件をみたすとする. 
  \begin{align*}
    &\textrm{(i)}\,P_0(a) = 1,\,P_n(a)=0 \quad ({}^{\forall}n\ge1)\\
    &\textrm{(ii)}\,\deg P_n = n \quad ({}^{\forall}n\ge0)\\
    &\textrm{(iii)}\,DP_n(x) = P_{n-1}(x) \quad ({}^{\forall}n\ge1), \quad D(1) = 0
  \end{align*}
ただし, $a\in\K$である. このとき, 任意の多項式$f(x)\in V$に対し, $\deg f(x)=N$とすると, 
  \[
    f(x) = \sum_{n=0}^N(D^nf)(a)P_n(x)
  \]
が成り立つ. 
\ethm
この定理を形式化すると以下のようになる. 
\begin{lstlisting}{Coq}
Theorem general_Taylor D n P (f : {poly R}) a :
  islinear D -> isfderiv D P ->
  (P 0%N).[a] = 1 ->
  (forall n, (P n.+1).[a] = 0) ->
  (forall m, size (P m) = m.+1) ->
  size f = n.+1 ->
  f = \sum_(0 <= i < n.+1)
          ((D \^ i) f).[a] *: P i. 
Proof.
  move=> Hl Hd HP0 HP HdP Hdf.
  have Hdf' : (size f <= n.+1)%N.
    by rewrite Hdf leqnn.
  move: (poly_basis n P f HdP Hdf') => [c] Hf.
  have Hc0 : c 0%N = ((D \^ 0) f).[a] => /=.
    rewrite Hf.
    destruct n.
      by rewrite big_nat1 hornerZ HP0 mulr1.
    rewrite hornersumD.
    rewrite (@big_cat_nat _ _ _ 1) //= big_nat1.
    rewrite hornerZ HP0 mulr1.
    have -> : (1 = 0 + 1)%N by [].
    rewrite big_addn subn1 /=.
    under eq_big_nat => i /andP [_ _].
      rewrite hornerZ addn1 HP mulr0.
    over.
    by rewrite big1 // addr0.
  have ithD : forall j, (j.+1 <= n)%N ->
    (D \^ j.+1) f = \sum_(j.+1 <= i < n.+1) c i *: P (i - j.+1)%N.
    move=> j Hj.
    rewrite Hf linear_distr; last by apply nth_islinear.
    rewrite {1}(lock j.+1).
    rewrite (@big_cat_nat _ _ _ j.+1) //=; last by apply leqW.
    rewrite -lock.
    under eq_big_nat => i /andP [_ Hi].
      rewrite nthisfderiv_0 // scaler0.
    over.
    rewrite big1 // add0r.
    by under eq_big_nat => i /andP [Hi _] do rewrite nthisfderiv_pos //.
  have coef : forall j, (j <= n)%N -> c j = ((D \^ j) f).[a].
    move=> j Hj.
    destruct j => //.
    rewrite ithD //.
    rewrite (@big_cat_nat _ _ _ j.+2) //= big_nat1 hornerD.
    rewrite subnn hornerZ HP0 mulr1 hornersumD.
    under eq_big_nat => i /andP [Hi Hi'].
      rewrite hornerZ.
      move: (Hi).
      rewrite -addn1 -leq_subRL //; last by apply ltnW.
      case: (i - j.+1)%N => // k Hk.
      rewrite HP mulr0.
    over.
    by rewrite big1 // addr0.
  rewrite {1}Hf big_nat_cond [RHS]big_nat_cond.
  apply eq_bigr => i /andP [/andP [Hi Hi'] _].
  by rewrite coef.
Qed.\end{lstlisting}
記号の意味などは以下の通りである. 
\begin{itemize}
  \item {\tt islinear}, {\tt isfderiv}はそれぞれ
    \begin{lstlisting}{Coq}
Definition islinear (D : {poly R} -> {poly R}) :=
  forall a b f g, D ((a *: f) + (b *: g)) = a *: D f + b *: D g.

Definition isfderiv D (P : nat -> {poly R}) := forall n,
  match n with
  | 0 => (D (P n)) = 0
  | n.+1 => (D (P n.+1)) = P n
  end. \end{lstlisting}
    という定義であり, 前者が線形作用素であること, 後者は条件(iii)を形式化したものである. 
  \item {\tt under / over}は総和$\sum$, 総積$\prod$など同じ演算を繰り返す記号
    (これを big operator と呼ぶ)に対して用いるタクティックで, 
    big operator で束縛されている各項を書き換えたい際に使う. 
    {\tt under}で各項に注目し, 書き換えが終わったら{\tt over}でもとの big operator に戻る. 
    big operator について詳しくは mathcomp の bigop.v を参照のこと.  
  \item \cite{Kac}での証明には, $\{P_0(x), P_1(x), \ldots , P_n(x)\}$が$V$の基底
    となることを用いている. これを以下のように形式化した. 
    \begin{lstlisting}{Coq}
Lemma poly_basis n (P : nat -> {poly R}) (f : {poly R}) :
  (forall m, size (P m) = m.+1) ->
  (size f <= n.+1)%N ->
  exists (c : nat -> R), f = \sum_(0 <= i < n.+1) c i *: P i. \end{lstlisting}
    この主張には係数列{\tt c}の一意性は含まれていないため, 実際には生成系であることを
    示しているが, それでも問題なく証明は完成する. 
\end{itemize}
この定理において, 
\[
  D \equiv D_q, \quad P_n \equiv \frac{(x-a)^n_q}{[n]!}
\]
(ただし, $n\in\Z_{\ge0}$に対し, $[n]!$を
\[
    [n]! \coloneqq \begin{cases}
                          1 & (n=0)\\
                          [n]\times[n-1]\times\cdots\times[1] & (n\ge1)
                        \end{cases}
\]
と定める)とすることで, 有限次Taylor展開の$q$-類似が得られる. 
\bthm[\cite{Kac} p12 Theorem 4.1] \label{q_Taylor}
$f(x)$を, $N$次の実数係数多項式とする. 任意の$c\in\R$に対し, 
  \[
    f(x) = \sum_{j=0}^N (D_q^jf)(c)\frac{(x-c)^j_q}{[j]!}
  \]
が成り立つ. 
\ethm
\bpf
$\frac{(x-a)^n_q}{[n]!}$が, $a$, $D_q$に対してTheorem \ref{general_Taylor}の三条件をみたすことを確かめればよい. (i), (ii)は$(x-a)^n_q$の定義から, (iii)はProposition\ref{Dq_qbinom_nonneg}から分かる. 
\epf
前節で準備した{\tt Dqp}, {\tt qbinom\_pos\_poly}を用いて Theorem \ref{q_Taylor}を形式化する. 
\begin{lstlisting}{Coq}
Fixpoint qfact n :=
  match n with
  | 0 => 1
  | n.+1 => qfact n * qnat n.+1
  end.

Theorem q_Taylorp n (f : {poly R}) c :
  (forall n, qfact n != 0) ->
  size f = n.+1 ->
  f = \sum_(0 <= i < n.+1) ((Dqp' \^ i) f).[c] *: (qbinom_pos_poly c i / (qfact i)%:P).
\end{lstlisting}
{\tt Dqp}, {\tt qbinom\_pos\_poly}をもとの定義に戻したものについては以下の通り. 
\begin{lstlisting}{Coq}
Theorem q_Taylor n (f : {poly R}) x c :
  q != 0 ->
  c != 0 ->
  (forall n, qfact n != 0) ->
  size f = n.+1 ->
  f.[x] =  \sum_(0 <= i < n.+1)
             ((Dq \^ i) # f) c * qbinom_pos c i x / qfact i.
\end{lstlisting}
\brmk
  約分のための$c \neq 0$という条件に加え, 高階$D_q$を扱うため前述の通り$q \neq 0$も
  必要となる. 具体的には高階{\tt Dqp'}と{\tt Dq}を一致させる補題
  \begin{lstlisting}{Coq}
Lemma hoDqp'_DqE p x n : q != 0 -> x != 0 ->
  ((Dqp' \^ n) p).[x] = ((Dq \^ n) # p) x.
Proof.
  move=> Hq0 Hx.
  rewrite /(_ # _).
  elim: n x Hx => [|n IH] x Hx //=.
  rewrite Dqp'_DqE // {2}/Dq /dq -!IH //.
  by apply mulf_neq0 => //.
Qed. \end{lstlisting}
  の証明において, {\tt IH}(Inductive Hypothesis, 帰納の仮定)を使う際に$q \ast x \neq 0$という条件が必要となる. 
\ermk
本論文の最後に, $x ^ n$と$(x - a)^n_q$にこのTaylor展開の$q$-類似を適用する. 
\blem[\cite{Kac} p12 Example (4.4)]
  $n \in \Z_{>0}$について, 
  \[
    x ^ n = \sum_{j = 0}^n \qcoe{n}{j} (x - 1)^j_q \quad
      \left( \text{ここで, }\qcoe{n}{j} \coloneqq \frac{[n]!}{[j]![n - j]!} \right)
  \]
  が成り立つ. 
\elem
\bpf
  Theorem \ref{q_Taylor}において, $f(x) = x^n$, $c = 1$とする. 
  任意の正整数$j \le n$に対して, $D_q x^n = [n] x ^{n -1}$より, 
  \[
    (D_q^j f) (x) = [n] [n - 1] \cdots [n - j +1] x^{n - j}
  \]
  となるので, 
  \[
    (D_q^j f)(1) = [n] [n - 1] \cdots [n - j +1]
  \]
  が得られる.   
\epf
\blem[\cite{Kac} p15 Example (5.5)]
  $n \in \Z_{>0}$について, 
  \[
    (x + a)^n_q = \sum_{j = 0}^n \qcoe{n}{j} q^{j (j - 1)/2} a^j x^{n - j}
  \]
  が成り立つ. この式は Gauss's binomial formula と呼ばれる. 
\elem
\bpf
  $f = (x + a)^n_q$とすると, 任意の正整数$j \le n$に対して, 
  \[
    (D_q ^j f) (x) = [n] [n - 1] [n - j + 1] (x + a)^{n - j}_q
  \]
  であり, また
  \[
    (x + a)^m_q = (x + a) (x + qa) \cdots (x + q^{m - 1} a)
  \]
  から, $(0 + a)^m_q = a \cdot qa \cdots q^{m - 1}a = q^{m (m - 1)/2}a^m$となるので, 
  \[
    (D_q^j f) (0) = [n] [n - 1] \cdots [n - j +1]q^{(n - j) (n - j - 1)/2} a^{n - j}
  \]
  が成り立つ. よって, Theorem \ref{q_Taylor} において, $f = (x + a)^n_q$, $c = 0$として, 
  \[
    (x + a)^n_q = \sum_{j = 0}^n \qcoe{n}{j} q^{(n - j) (n - j - 1)/2} a^{n - j} x^j
  \]
  が得られる. この式の右辺において$j$を$n - j$に置き換えることで, 
  \[
    \qcoe{n}{n - j} = \frac{[n]!}{[n - j]![n - (n - j)]!} = \frac{[n]!}{[j]![n - j]!} = \qcoe{n}{j}
  \]
  に注意すれば, 
  \[
    (x - a)^n_q = \sum_{j = 0}^n \qcoe{n}{j} q^{j (j - 1)/2} a^j x^{n - j}
  \]
  が成り立つ. 
\epf
この二つの等式の形式化はそれぞれ次の通り. 
\begin{lstlisting}{Coq}
Lemma q_Taylorp_pow n : (forall n, qfact n != 0) ->
  'X^n = \sum_(0 <= i < n.+1) (qbicoef n i *: qbinom_pos_poly 1 i).

Definition qbicoef n j := qfact n / (qfact j * qfact (n - j)).
Theorem Gauss_binomial a n : (forall n, qfact n != 0) ->
  qbinom_pos_poly (-a) n =
  \sum_(0 <= i < n.+1) (qbicoef n i * q ^+ (i * (i - 1))./2 * a ^+ i) *: 'X^(n - i). \end{lstlisting}
\brmk
{\tt Gauss\_binomial}は{\tt q\_Taylorp}において{\tt c = 0}として証明している. {\tt q\_Taylorp}では約分の計算をしているが, 多項式を用いて定義しているため$0$での値を計算できる. 
\ermk
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{今後の展望}
今後の展望としては, まずはこれまでに形式化した$q$-類似の各概念が$q \to 1$としたときに通常の数学の概念に一致することの形式化を行いたい. このためには, 現在開発中のライブラリである mathcomp analysis\cite{coq ana}を用いる必要がある. また, このライブラリを用いると無限和に関する形式化も可能であるため, Gauss's binomial formula を無限に拡張したものや, 無限和を用いて定義される指数関数, 三角関数の$q$-類似の形式化にも挑戦していきたい. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{少人数クラスまとめ} \label{chap hott}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{はじめに}
本章では, \cite{hott}を教科書にして修士2年次に少人数クラスで学習した Homotopy Type Theory (HoTT) についてまとめる. HoTT とは, 
\begin{align*}
  \text{$a$が型$A$の要素である} &\leftrightarrow \text{$a$が空間$A$の点である} \\
  \text{$a = b$である} &\leftrightarrow \text{点$a$と点$b$の間にパスが存在する}
\end{align*}
というように, 型理論に対してホモトピー的解釈を与えたものである. \ref{sec ua}節で HoTT の大きな特徴の一つである, univalence axiom について説明する. 大雑把にいえば, univalence axiom は「型$A$と型$B$が同型ならば, $A$と$B$は等しい」という公理である. この意味を正確にとらえるため, 型同士の等しさや同型を定義していく. また, いくつかの定義や補題を準備した後, univalence axiom から関数の外延性がしたがうことを\ref{sec funext}節で確認する. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{型から型を作る} \label{sec inductive}
$A$と$B$の2つの型が与えられたとき, そこから関数型$A \to B$が構成できる. このとき, 
\begin{align*}
  f : A \to B,\ a : A &\Lra f(a) : B \\
  a : A,\ b(x) : B &\Lra \lambda a. b : A \to B 
\end{align*}
である. より一般に, 型$A$と$A$上の型族$B \to \U$が与えられれば($\U$はユニバース), 依存関数型$\prod_{a : A} B(a)$が構成でき, 
\begin{align*}
  f :\prod_{a : A} B(a),\ a : A &\Lra f(a) : B(a) \\
  a : A,\ b(x) : B(x) &\Lra \lambda a. b : \prod_{a : A} B(a) 
\end{align*}
である. さらに, 既存の型から新たな型を作るやり方として, 構成規則, 導入規則, 除去規則, 計算規則の4つを与える帰納的な方法がある. 例えば, 依存和型$\sum_{x : A} B(x)$は, 
\begin{itemize}
  \item 構成規則：$A : \U$, $B : A \to \U \Lra \sum_{x : A} B(x)$
  \item 導入規則：$a : A$, $b : B(a) \Lra (a, b) : \sum_{x : A} B(x)$
  \item 除去規則：ind$_{\sum_{x : A} B(x)} : \prod_{C : (\sum_{x : A} B(x)) \to \U} 
                               \left(\prod_{a : A} \prod_{b : B(a)} C((a, b)) \right) \to 
                                      \prod_{w : \sum_{x : A} B(x)} C(w)$
  \item 計算規則：ind$_{\sum_{x : A} B(x)} (C, g, (a, b)) :\equiv g(a)(b)$
\end{itemize}
で定義できる. 除去規則は, 「任意の$w : \sum_{x : A} B(x)$について$C(w)$を示したければ, 任意の$a : A$, $b : B(a)$について$C((a, b))$を示せばよい」と読むことができる. 
ここで, Curry-Howard 同型に基づいて考えると, 「ある要素$a$とある要素$b$が等しい」という命題は, なにかしらの型と対応するはずである. よってその型 identity type を, 
\begin{itemize}
  \item 構成規則：$A : \U \Lra \_ =_A \_ : \U$
  \item 導入規則：refl$_a : \prod_{a : A} (a =_A a)$
  \item 除去規則：ind$_{=_A} : \prod_{\left( C : \prod_{(x, y : A)} (x =_A y) \to \U \right)} 
                                       \left( \prod_{(x : A)} C(x, x, {\rm refl}_x) \right) \to
                                       \prod_{(x, y : A)} \prod_{(p : x =_A y)} C(x, y, p)$
  \item 計算規則：ind$_{=_A} (C, c, x, x, {\rm refl}_x) : \equiv c(x)$
\end{itemize}
と定義する. 除去規則は, 依存和型のときと同様に考えると, 「任意の$x$, $y : A$, $x = y$について$C(x, y, p)$を示したければ, 任意の$x : A$について$C(x, x, \refl{x})$を示せばよい」となる. 以下, この identity type の除去規則を用いることを path induction と呼ぶ. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{型の同型}
ここで, 型と型の間の同型を定義したい. まず, 関数の間のホモトピーを定義する. 
\bdf[\cite{hott} Definition 2.4.1]
  $A : \U$, $P : A \to \U$とする. $f$, $g : \prod_{x : A} P(x)$に対して, 
  \[
    (f \sim g) :\equiv \prod_{x : A} (f(x) = g(x))
  \]
  と定める. 
\edf
次に, 「逆写像」を定義する. 
\bdf[\cite{hott} Definition 2.4.6]
  $A$, $B : \U$, $f : A \to B$とする. このとき, $f$の quasi-inverse qinv($f$)を, 
  \[
    \qinv(f) :\equiv \sum_{g : B \to A} ((f \circ g \sim \id_B) \times
                                                   (g \circ f \sim \id_A))
  \]
\edf
例えば, id$_A$の quasi-inverse はid$_A$自身である. さらに, この qinv を用いて, isequiv を, 
\begin{itemize}
  \item qinv($f$) $\to$ isequiv($f$)
  \item isequiv($f$) $\to$ qinv($f$)
  \item $e_1$, $e_2 :$isequiv($f$) ならば $e_1 = e_2$
\end{itemize}
をみたすものとして定義したい. ここでは, 
\[
  \iseq(f) :\equiv \left( \sum_{g : B \to A} (f \circ g \sim \id_B) \right) \times
                           \left( \sum_{h : B \to A} (h \circ f \sim \id_A) \right) \quad
                           \text{(\cite{hott} p73 (2.4.10))}
\]
と定めることにする. 関数$f$について$\iseq(f)$が成り立つとき, $f$は equivalence であるという. 

isequiv を使って型同士の同型を定義する. 
\bdf[\cite{hott} p73 (2.4.11)]
  $A$, $B : \U$について, 
  \[
    A \simeq B :\equiv \sum_{f : A \to B} \iseq(f)
  \]
  と定める. 
\edf
型の同型については, 例えば以下のような例がある. 
\bex[\cite{hott} Lemma 2.4.12]
$A$, $B$, $C : \U$について, 
\begin{itemize}
  \item $A \simeq A$
  \item $A \simeq B \to B \simeq A$
  \item $A \simeq B \to B \simeq C \to A \simeq C$
\end{itemize}
が成り立つ. 
\eex
\bex[\cite{hott} Exercise 2.10] \label{ex sigA}
  $\sum$型は「結合的」である. つまり任意の型$A$, 型族$B : A \to \U$, 
  型族上の型族$C : (\sum_{x : A} B(x)) \to \U$に対して, 
  \[
    \left( \sum_{x : A} \sum_{y : B(x)} C((x, y))\right) \simeq
    \left( \sum_{p : \sum_{x : A} B(x)} C(p) \right)
  \]
  が成り立つ. 
\eex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Univalence axiom} \label{sec ua}
これまでに定義した$=$と$\simeq$を用いて, univalence axiom の主張を正しく述べる. まず, 
\[
  \textrm{idtoeqv} : \prod_{A, B : \U} (A =_{\U} B) \to (A \simeq B)
    \quad (\text{\cite{hott} p89 (2.10.2)})
\]
を定める. この関数が存在することは, path induction よりわかる(\cite{hott} Lemma 2.10.1). このidtoeqvに対して, 
\begin{shadebox}
\begin{axi}[\cite{hott} Axiom 2.10.3]
  \[
    \textrm{ua} : \prod_{A, B : \U} \iseq(\textrm{idtoeqv}(A, B))
  \]
\end{axi}
\end{shadebox}
が univalence axiom である. とくに, この公理を仮定すれば, 
\[
  (A =_{\U} B) \simeq (A \simeq B)
\]
が成り立つ. \ref{sec inductive}章のときのように, $\ua$や$\ide$を$A =_{\U} B$という型を構成する規則だと考えれば, 
\begin{itemize}
  \item 導入規則：$A : \U,\ B: \U \Lra \ua : (A \simeq B) \to (A =_{\U} B)$
  \item 除去規則：$\ide \equiv \tp^{X \mapsto X} : (A =_{\U} B) \to (A \simeq B)$
  \item (propositional)計算規則：$\ide (\ua (f), x) = f(x)$
  \item (propositional)一意性：任意の$p : A = B$について, $p = \ua (\ide (p))$
\end{itemize}
となる($\tp$の定義は\cite{hott} p72 Lemma 2.3.1). univalence axiom をみたすようなユニバース$\U$を univalent であるという.  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{関数の外延性} \label{sec funext}
関数$f$, $g$について, 
\[
  f = g \lra \text{任意の$f$, $g$の定義域の要素$x$に対して, $f(x) = g(x)$}
\]
という関数の外延性の公理について述べる. 正確には, まず path induction から, 
依存関数$f$, $g : \prod_{x : A} B(x)$に対して
\[
  \happ : (f = g) \to (f \sim g) \left( \prod_{x : A} (f(x) = g(x))\right)
    \quad (\text{\cite{hott} p86 (2.9.2)})
\]
という関数を定義できる. このとき, 
\baxi[\cite{hott} Axiom 2.9.3]
  任意の$A$, $B$, $f$, $g$について, $\happ$は equivalence である
\eaxi
を関数の外延性と呼ぶ. この公理から$\happ$の quasi-inverse
\[
  \textrm{funext} : \left( \prod_{x : A} (f(x) = g(x)) \right) \to (f = g)
\]
の存在が従う. この関数のことを関数の外延性と呼ぶこともある. univalence axiom のときと同じように考えると,
\begin{itemize}
  \item 導入規則：$\fune$
  \item 除去規則：$\happ$
  \item (propositional)計算規則：$\happ (\fune (h), x) = h(x)
    \quad \left(h : \prod_{x : A} (f(x) = g(x)) \right)$
  \item (propositional)一意性：$p = \fune (x \mapsto \happ(p, x)) \quad (p : f = g)$
\end{itemize}
となる. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{可縮, ファイバー}
この章と次の章では, univalence axiom から関数の外延性が従うことを示すために必要な定義や補題の準備をする. まずは, 型が可縮であるということを定義する. 
\bdf[\cite{hott} Definition 3.11.1]
  $A$を型とする. 中心と呼ばれる$a : A$が存在して, 任意の$x : A$に対して$a = x$をみたす
  とき, $A$は可縮(contractible)であるという. このことを表す型$\iscont (A)$を, 
  \[
    \iscont (A) :\equiv \sum_{a : A} \prod_{x : A} (a = x)
  \]
  と定める. 
\edf
次に, ホモトピー論ではホモトピーファイバーに対応する概念を定める. 
\bdf[\cite{hott} Definition 4.2.4]
  関数$f : A \to B$の点$y : B$の上でのファイバーを
  \[
    \fib_f(y) :\equiv \sum_{x : A} (f(x) = y)
  \]
  と定める. 
\edf
このファイバーを用いて, 関数の可縮性を定義する. 
\bdf[\cite{hott} Definition4.4.1]
  関数$f : A \to B$が可縮であるとは, 任意の$y : B$に対して$\fib_f{y}$が可縮であることである. 
  このことを表す型$\iscont (f)$を, 
  \[
    \iscont (f) :\equiv \prod_{y : B} \iscont (\fib_{f}(y))
  \]
  と定める. 
\edf
このように定義した$\iscont (f)$について, 
\[
  \iscont (f) \simeq \iseq (f)
\]
が成り立つ(\cite{hott} p138 4.5節参照). よって, ある関数が equivalence であることを示すには, 可縮であることを示せば十分である. 可縮性に関するものでよく使う補題として, 以下のようなものがある. 
\blem[\cite{hott} Lemma 3.11.8] \label{lem sigeq_cont}
  任意の$A$, $a : A$について, $\sum_{x : A} (a = x)$は可縮である
\elem
\blem[\cite{hott} Lemma 3.11.9] \label{lem sig_eq}
  $P : A \to \U$を型族とする. このとき, 以下の2つが成り立つ. 
  \begin{enumerate}
    \item 各$P(x)$が可縮である, $\sum_{x : A} P(x) \simeq A$
    \item $A$が$a$を中心として可縮であるとき, $\sum_{x : A} P(x) \simeq P(a)$
  \end{enumerate}
\elem
この2つの補題と univalence axiom から示せることとして,  
\blem[\cite{hott} Lemma 4.8.1] \label{lem fib_pr_eq}
  任意の型族$B : A \to \U$について, $\pr_1 : \sum_{x : A} B(x) \to A$の$a : A$上での
  ファイバーは$B(a)$と同型である, つまり, 
  \[
    \fib_{\pr_1} (a) \simeq B(a)
  \]
  が成り立つ. 
\elem
\bpf
  \begin{align*}
    \fib_{\pr_1} (a) &\equiv \sum_{u : \sum_{x : A} B(x)} \pr_1 (u) a \\
                        &\simeq \sum_{x : A} \sum_{b : B(x)} (x = a)
                          \quad \text{(by Example \ref{ex sigA})} \\
                        &\simeq \sum_{x : A} \sum_{b : B(x)} \sum_{p : x = a} \textbf{1} \\
                        &\simeq \sum_{x : A} \sum_{p : x = a} \sum_{b : B(x)} \textbf{1} \\ 
                        &\simeq \sum_{x : A} \sum_{p : x = a} B(x) \\
                        &\simeq B(a)
                    \quad \text{(by Example \ref{ex sigA}, Lemma \ref{lem sigeq_cont}, 
                                          Lemma \ref{lem sig_eq})}
  \end{align*}
\epf
がある. この補題は, 写像はファイブレーションと同型であるというホモトピー論での基本的な結果に対応している.  
最後に, ファイバーごとの equivalence は全空間(total space)の equivalence という言葉で特徴付けられることを示す. 
\bdf[\cite{hott} Definition 4.7.5]
  型族$P$, $Q : A \to \U$と依存関数$f : \prod_{x : A} P(x) \to Q(x)$
  (このような関数を fiberwise map または fiberwise transformation と呼ぶ)が与えられたとき, 
  \[
    \total (f) :\equiv \lambda w.\ (\pr_1 w, f(\pr_1 w, \pr_2 w)) :
      \sum_{x : A} P(x) \to \sum_{x : A} Q(x)
  \]
  と定める. 
\edf
\bthm[\cite{hott} Theorem 4.7.6] \label{thm_total}
  $f$が$A$上の型族$P$と$Q$の間の fiberwise transformation 
  (つまり$f : \prod_{x : A} P(x) \to Q(x)$)であり, $x : A$と$v : Q(x)$が与えられたとする. このとき, 
  \[
    \fib_{\total(f)} ((x, v)) \simeq \fib_{f(x)} (v)
  \]
  である. 
\ethm
\bpf
  \begin{align*}
    \fib_{\total(f)} ((x, v))
    &\equiv \sum_{w : \sum_{x : A} P(x)} (\pr_1 w, f(\pr_1 w, \pr_2 w)) = (x, v)\\
    &\simeq \sum_{a : A} \sum_{u : P(a)} (a, f(a, u)) = (x, v)
      \quad \text{(by Example \ref{ex sigA})}\\
    &\simeq \sum_{a : A} \sum_{u : P(a)} \sum_{p : a = x} p_* (f(a, u)) = v
      \quad \text{(by \cite{hott} Theorem 2.7.2)}\\
    &\simeq \sum_{a : A} \sum_{p : a = x} \sum_{u : P(a)} p_* (f(a, u)) = v\\
    &\simeq \sum_{g : \sum_{a : A} a = x}
                  \left( \sum_{u : P(\pr_1 (q))} (\pr_2 (q))_* (f (pr_1(q), u) = v \right)
      \quad \text{(by Example \ref{ex sigA})}\\
    &\simeq \sum_{u : P(x)} (\refl_x)_* (f(x, u) = v)
     \quad \text{(by Lemma \ref{lem sigeq_cont} and
       Lemma \ref{lem sig_eq} (ii) as center $\equiv (x, \refl_x)$)}\\
    &\simeq \sum_{u : P(x)} f (x, u) = v
  \end{align*}
\epf
fiberwise transformation $f : \prod_{x : A} P(x) \to Q(x)$が fiberwise equivalence であるということを, 任意の$x : A$について$f(x) : P(x) \to Q(x)$が equivalence であることと定めると, 以下が成り立つ. 
\bthm[\cite{hott} Theorem 4.7.7] \label{thm fibeq_totaleq}
  $f$を$A$上の型族$P$と$Q$の間の fiberwise transformation とする. このとき, 
  $f$が fiberwise equivalence であることと$\total (f)$が equivalence であることは同値である
\ethm
\bpf
  \begin{align*}
    f \text{が fiberwise equivalence} &\equiv \prod_{x : A} \iseq (f(x)) \\
                                                &\lra \prod_{x : A} \iscont (f(x)) \\
                                     &\equiv \prod_{x : A} \prod_{v : Q(x)} \iscont (\fib_{f(x)} (v)) \\
                           &\simeq \prod_{x : A} \prod_{v : Q(x)} \iscont (\fib_{\total(f)} ((x, v)))
                             \quad \text{(by Theorem \ref{thm_total})} \\
                           &\lra \prod_{w : \sum_{x : A} Q(x)} \iscont (\fib_{\total(f)} (w)) \\
                           &\equiv \iscont (\total(f)) \\
                           &\lra \iseq (\total(f))
  \end{align*}
\epf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{レトラクト} \label{sec retract}
この章では, 型のレトラクトと関数のレトラクトをそれぞれ定義し, 後の章で使う補題を紹介する. 
まず, 型のレトラクトと定義は以下の通りである. 
\bdf[\cite{hott} p125]
  型$A$, $B$について, 2つの関数レトラクション$r : A \to B$とセクション$s : B \to A$が存在し, 
  更にホモトピー
  \[
    \epsilon : \prod_{y : B} (r(s(y)) = y)
  \]
  が存在するとき, $B$は$A$のレトラクトであるという. 
\edf
このレトラクトに対して, 次の補題が成り立つ. 
\blem[\cite{hott} Lemma 3.11.7] \label{lem ret_cont}
  $B$が$A$のレトラクトであり, かつ$A$が可縮であるとき, $B$も可縮である. 
\elem
次に, 関数のレトラクトを定義する. 
\bdf[\cite{hott} Definition 4.7.2] \label{def_retract}
  関数$g : A \to B$が関数$f : X \to Y$のレトラクトであるとは, 4つのホモトピー
  \begin{align*}
    &R : r \circ s \sim \id_{A} \\
    &R' : r' \circ s' \sim \id_{b} \\
    &L : f \circ s \sim s' \circ g \\
    &K : g \circ r \sim r' \circ f
  \end{align*}
  が存在するような$r : X \to A$, $s : A \to X$, $r' : Y \to B$, $s' : B \to Y$が存在し, 更に
  任意の$a : A$に対して, パス
  \[
    H(a) : K(s(a)) \cdot r'(L(a)) = g(R(a)) \cdot R'(g(a)) ^ {-1}
  \]
  が存在することをいう. 
\edf
この定義において, ホモトピー$R$, $R'$はそれぞれ$A$が$X$のレトラクト, $B$が$Y$のレトラクトであるという条件である. 
また, 型についてのレトラクションは, 上の定義において$B \equiv Y \equiv \textbf{1}$としたときの特別な場合である. 関数のレトラクトについて, まず次のことが成り立つ. 
\blem[\cite{hott} Lemma 4.7.3] \label{lem_close_retract}
  関数$g : A \to B$が関数$f : X \to Y$のレトラクトであるならば, $\fib_g(b)$は$\fib_f(s'(b))$の
  レトラクトである. ただし, $s'$は Definition \ref{def_retract}のものとする. 
\elem
\bpf
  証明の概略を述べる. 
  Definition \ref{def_retract} の通りに記号を定める. 任意の$b : B$に対して, 
  \begin{align*}
    &\varphi_b : \fib_g (b) \to \fib_f (s'(b)), \quad
      \varphi (a, p) :\equiv (s(a), L(a) \cdot s'(p)) \\
    &\psi_b : \fib_f(s'(b)) \to \fib_g (b), \quad
      \psi (x, q) :\equiv (r(x), K(x) \cdot r'(q) \cdot R'(b))
  \end{align*}
  と定義したとき, ($\sum$の induction から)任意の$(a, p) : \fib_g (b)$に対して
  $\psi_b \varphi (a, p) = (a, p)$が成り立つ, つまり
  \[
    \prod_{b : B} \prod_{a : A} \prod_{p : g(a) = b} \psi_b \varphi (a, p) = (a, p)
  \]
  を示せば良い. 詳細は\cite{hott} p140 参照のこと. 
\epf
この補題から, equivalence とレトラクトに関する補題が従う. 
\bthm[\cite{hott} Theorem 4.7.4]
  $g$が equivalence な$f$のレトラクトであれば, $g$も equivalence である. 
\ethm
\bpf
  Lemma \ref{lem_close_retract} より, $g$の任意のファイバーは$f$のファイバーのレトラクトで
  あり, $\iseq (f) \lra \iscont (f)$と Lemma \ref{lem ret_cont} から$\iseq (g)$が分かる. 
\epf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{関数の外延性を Univalence axiom から導く} \label{sec funext}
最後に, univalence axiom から関数の外延性が導けることを示す.
%よって, この節では関数の外延性を仮定しない. 
証明は, まず univalence axiom から弱い関数の外延性が導けることを示し, 次に弱い関数の外延性から通常の関数の外延性が従うことを示すという2段階で行われる. 
$\U$をユニバースとし, どこで univalent を仮定しているかを明記することにする. 
\bdf[\cite{hott} Lemma 4.9.1]
  弱い関数の外延性の公理を, 任意の$A$上の型族$B : A \to \U$に対して
  \[
    \left( \prod_{x : A} \iscont(B(x)) \right) \to \iscont \left( \prod_{x :A} B(x) \right)
  \]
  が成り立つことと定義する. 
\edf
次の補題は関数の外延性を仮定すればすぐに証明できるが, 関数の外延性を仮定しなくても univalence axiom から証明できるのがポイントである. 
\blem[\cite{hott} Lemma 4.9.2] \label{lem XA_eq_XB}
  $\U$が univalent であると仮定する. 任意の$A$, $B$, $X : \U$と任意の$e : A \equiv B$
  に対して, 
  \[
    (X \to A) \simeq (X \to B)
  \]
  の同型射は, $(e(\text{の同型射}) \circ -)$で与えられる. 
\elem
\bpf
  ある$p : A = B$について$e = \idtoeqv (p)$と仮定してよい. 
  よって, path induction より $B \equiv A$, $p \equiv \refl_{A}$とすれば, 
  $e = \idtoeqv(\refl_A) = \id_A$となる. このとき, $(e \circ -)$は$(\id_A \circ -)$となり, これは
  $X \to A$上の$\id$であるので, equivalence である. 
\epf
\bcor[\cite{hott} Corollary 4.9.3] 
  $P : A \to \U$を可縮な型の族, つまり$\prod_{x : A} \iscont(P(x))$とする. このとき, 
  射影$\pr_1 : (\sum_{x : A} P (x)) \to A$は equivalence である.
  更に, $\U$が univalent であれば, 
  \[
    (\pr_1 \circ -) : \left( A \to \sum_{x : A} P(x) \right) \simeq (A \to A)
  \]
  である. 
\ecor
\bpf
  前半について, Lemma {\ref{lem fib_pr_eq}} から, $x : A$について, $\fib_{\pr_1} (x) \equiv P(x)$である. 
  $P$が可縮な型の族なので, $\iscont(\pr_1)$が成り立つ.
  後半については, Lemma \ref{lem XA_eq_XB} よりわかる. 
\epf
上記の$\alpha \equiv (\pr_1 \circ -)$のホモトピーファイバーは可縮であるため, 特に$\id_A$上でも可縮, つまり$\iscont(\fib_{\alpha} (\id_A))$である. よって, $\prod_{x : A} P(x)$が
$\fib_{\alpha} (\id_A)$のレトラクトであることを示せば, 弱い関数の外延性が univalence axiom から従うことになる. 
\bthm[\cite{hott} Theorem 4.9.4]
  $\U$が univalent であるとし, $P : A \to \U$を可縮な型の族とする. 
  $\alpha : \left( A \to \sum_{x : A} P(x) \right) \equiv (A \to A)$とすると, 
  $\prod_{x : A} P(x)$は$\fib_{\alpha} (\id_A)$のレトラクトである. つまり, $\prod_{x : A} P(x)$
  は可縮となるので, univalence axiom から弱い関数の外延性の公理が従う. 
\ethm
\bpf
  関数$\varphi : (\prod_{x : A} P(x)) \to \fib_{\alpha} (\id_A)$, 
  $\psi : \fib_{\alpha} (\id_A) \to \prod_{x : A} P(x)$をそれぞれ, 
  \begin{align*}
    \varphi (f) :\equiv (\lambda x.\ (x, f(x)), \refl_{id_A}) \\
    \psi (g, p) :\equiv \lambda x.\ \happ (p, x)_* (\pr_2(g(x)))
  \end{align*}
  と定める. このとき, 
  \begin{align*}
    \psi (\varphi (f)) &\equiv \lambda x.\ \happ (\refl_{id_A}, y)_* (\pr_2(x, f(x))) \\
                           &\equiv \lambda x.\ \refl_* (f(x)) \\
                           &\equiv \lambda x.\ f(x) \\
                           &= f
  \end{align*}
  より成り立つ. 
\epf
\bthm[\cite{hott} Theorem 4.9.5] \label{thm weakfe_to_fe}
  弱い関数の外延性から通常の関数の外延性が従う. 
\ethm
\bpf
示したいことは
  \[
    \prod_{A : \U} \prod_{P : A \to P} \prod_{f, g : \prod_{x : A} P(x)} \iseq (\happ (f, g))
  \]
  である. このとき, 
  \[
    \prod_{g : \prod_{x : A} P (x)} \iseq (\happ(f, g))
  \]
  は, $\lambda g.\ \happ (f, g)$が fiberwise equivalence であるということなので, 
  Theorem \ref{thm fibeq_totaleq} から, 
  \[
    \total (\lambda g.\ \happ (f, g)) : \sum_{g : \prod_{x : A} P (x)} (f = g) \to
                                                 \sum_{g : \prod_{x : A} P (x)} (f \sim g)
  \]
  が equivalence であればよい. ここで, Lemma \ref{lem sigeq_cont} より
  送り元の型は可縮なので, 送り先の型
  \[
    \sum_{g : \prod_{x : A} P (x)} \prod_{x : A} (f(x) = g(x))
  \]
  が可縮であれば十分である. \cite{hott} Theorem 2.15.7 の証明のうち, 関数の外延性を
  仮定しなければ, 
  \[
    \sum_{g : \prod_{x : A} P (x)} \prod_{x : A} (f(x) = g(x))
  \]
  は
  \[
    \prod_{x : A} \sum_{u : P(x)} f(x) = u
  \]
  のレトラクトであることが示せる(逆向きの合成が$\id$とホモトピックであることにのみ
  関数の外延性を使っている).さらに, $\sum_{u : P(x)} f(x) = u$は Lemma \ref{lem sigeq_cont}
  から可縮であるため, 弱い関数の外延性から$\prod_{x : A} \sum_{u : P(x)} f(x) = u$も
  可縮になる. したがって, 
  \[
    \sum_{g : \prod_{x : A} P (x)} \prod_{x : A} (f(x) = g(x))
  \]
  も可縮である.  
\epf
\brmk
  Theorem \ref{thm weakfe_to_fe} の証明には univalent axiom は用いていない. 
\ermk
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{9}
  \bibitem{Bar} Henk Barendregt, {\it Lambda Calculi with Types}.  
    In S. Abramsky, Dov M. Gabbay, S. E. Maibaum, 
    {\it Handbook of logic in computer science (vol. 2): background:
     computational structures}, Oxford University Press, 1993.
  \bibitem{coq sl} Coq Team, {\it The Coq Standard Library}, 
  \url{https://coq.inria.fr/distrib/current/stdlib/}, 2023.
  \bibitem{Hag} 萩原 学/アフェルト・レナルド, {\it Coq/SSReflect/Mathcomp}, 森北出版, 
    2018.
  \bibitem{Kac} Victor Kac, Pokman Cheung, {\it{Quantum Calculus}}, Springer, 2001.
  \bibitem{coq mc} Mathematical Components Team, {\it Mathematical Components}, \url{https://github.com/math-comp/math-comp}, 2023.
  \bibitem{coq ana} Mathematical Components Team, 
  {\it Mathematical Components compliant Analysis Library}, 
  \url{https://github.com/math-comp/analysis}, 2023.
  \bibitem{coq qana} 中村 薫, {\it q-analogue}, \url{https://github.com/nakamurakaoru/q-analogue/tree/thesis}, 2023.
%  \bibitem{coq poly} \url{https://github.com/math-comp/math-comp/blob/master/ 
%                                 mathcomp/algebra/poly.v}
  \bibitem{Ume} 梅村 浩, 『楕円関数論  楕円曲線の解析学』, 東京大学出版会, 2000.
  \bibitem{hott} The Univalent Foundations Program, 
                      {\it{Homotopy Type Theory: Univalent Foundations of Mathematics}}, 
                      \url{https://homotopytypetheory.org/book}, 2013.
\end{thebibliography}
\end{document}
