\documentclass[dvipdfmx,cjk]{beamer}
\usetheme{Madrid} %スライドのスタイル
\setbeamertemplate{navigation symbols}{} %アイコン消す
\usefonttheme{professionalfonts} %数学用のフォント
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{ascmac}
\newtheoremstyle{mystyle}% % Name
    {}%                      % Space above
    {}%                      % Space below
    {\normalfont}%           % Body font
    {}%                      % Indent amount
    {\bfseries}%             % Theorem head font
    {}%                      % Punctuation after theorem head
    { }%                     % Space after theorem head, ' ', or \newline
    {}%                      % Theorem head spec (can be left empty, meaning `normal')
\theoremstyle{mystyle}
\usepackage{amssymb}
\usepackage{ascmac}
\usepackage{txfonts}
%\usepackage{graphics}
\input{poster_packages.tex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setbeamertemplate{theorems}[numbered]  %% 定理に番号をつける
\newtheorem{df}{$\textrm{Definition}$}[section]
\newtheorem{ex}[df]{$\textrm{Example}$}
\newtheorem{prop}[df]{$\textrm{Proposition}$}
\newtheorem{lem}[df]{$\textrm{Lemma}$}
\newtheorem{cor}[df]{$\textrm{Corollary}$}
\newtheorem{rmk}[df]{$\textrm{Remark}$}
\newtheorem{thm}[df]{$\textrm{Theorem}$}
\newtheorem{axi}[df]{$\textrm{Axiom}$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% theorems %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\bdf}{\begin{shadebox} \begin{df}}
\newcommand{\edf}{\end{df} \end{shadebox}}
\newcommand{\bex}{\begin{ex}}
\newcommand{\eex}{\end{ex}}
\newcommand{\bprop}{\begin{shadebox} \begin{prop}}
\newcommand{\eprop}{\end{prop} \end{shadebox}}
\newcommand{\blem}{\begin{shadebox} \begin{lem}}
\newcommand{\elem}{\end{lem} \end{shadebox}}
\newcommand{\bcor}{\begin{shadebox} \begin{cor}}
\newcommand{\ecor}{\end{cor} \end{shadebox}}
\newcommand{\brmk}{\begin{rmk}}
\newcommand{\ermk}{\end{rmk}}
\newcommand{\bthm}{\begin{shadebox} \begin{thm}}
\newcommand{\ethm}{\end{thm} \end{shadebox}}
\newcommand{\baxi}{\begin{shadebox} \begin{axi}}
\newcommand{\eaxi}{\end{axi} \end{shadebox}}
\newcommand{\bpf}{\begin{proof}}
\newcommand{\epf}{\end{proof}}
%% always %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Lra}{\Longrightarrow}
\newcommand{\Llra}{\Longleftrightarrow}
\newcommand{\lra}{\leftrightarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\ol}[1]{{\overline{#1}}}
\newcommand{\ul}[1]{{\underline{#1}}}
%% sets %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\D}{\mathbb{D}}
%% q-analogue %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\qcoe}[2]{\left[\begin{array}{ccc}#1\\#2\end{array}\right]}
%% algebra %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\plim}{{\displaystyle \lim_{\substack{\longleftarrow\\ n}}}}
\newcommand{\seq}[2]{(#1_{#2})_{#2\ge1}}
\newcommand{\Zmod}[1]{\Z/p^{#1}\Z}
\newcommand{\sem}[1]{[\hspace{-2pt}[{#1}]\hspace{-2pt}]}
\newcommand{\pros}[1]{\begin{array}{c} \ast \ast\\ \tt{#1} \end{array}}
%% Jones %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\pgm}[1]{{\tt{#1}}\text{-プログラム}}
\newcommand{\pgms}[1]{{\tt{#1}}\text{-プログラム集合}}
\newcommand{\dtm}[1]{{\tt{#1}}\text{-データ}}
\newcommand{\data}[1]{{\tt{#1}}\text{-データ集合}}
\newcommand{\rtf}[3]{time^{\tt{#1}}_{\tt{#2}}({\tt{#3}})}
%% Barendiregt %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\T}{\mathbb{T}}
\newcommand{\V}{\mathbb{V}}
\newcommand{\cT}{\mathcal{T}}
\newcommand{\uhr}{\upharpoonright}
\newcommand{\thra}{\twoheadrightarrow}
\newcommand{\lama}{\lambda \! \! \to}
%% HoTT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\U}{\mathcal{U}}
\newcommand{\id}{\textrm{id}}
\newcommand{\refl}{\textrm{refl}}
\newcommand{\ap}{\textrm{ap}}
\newcommand{\apd}{\textrm{apd}}
\newcommand{\pr}{\textrm{pr}}
\newcommand{\tp}{\textrm{transport}}
\newcommand{\qinv}{\textrm{qinv}}
\newcommand{\iseq}{\textrm{isequiv}}
\newcommand{\peq}{\textrm{pair}^=}
\newcommand{\sig}[3]{\sum_{{#1} : {#2}} {#3}\ ({#1})}
\newcommand{\0}{\textbf{0}}
%\newcommand{\1}{\textbf{1}}
%\newcommand{\2}{\textbf{2}}
\newcommand{\fune}{\textrm{funext}}
\newcommand{\happ}{\textrm{happly}}
\newcommand{\ua}{\textrm{ua}}
\newcommand{\ide}{\textrm{idtoequiv}}
\newcommand{\set}[1]{\textrm{isSet({#1})}}
\newcommand{\fib}{\textrm{fib}}
\newcommand{\iscont}{\textrm{isContr}}
\newcommand{\total}{\textrm{total}}
\newcommand{\idtoeqv}{\textrm{idtoeqv}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\title{$q$-類似の Coq による形式化}
\author[中村　薫]{アドバイザー $\colon$ Jacques Garrigue教授\\
           学籍番号 $\colon$ 322101289\\
           氏名 $\colon$ 中村　薫}
\date{\today}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\tableofcontents
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{はじめに}

\begin{frame}
  \tableofcontents[currentsection] 
\end{frame}

\begin{frame}[fragile]{はじめに}
	目的：$q$-類似の初等的な結果を Coq を用いて形式化する \pause
 	\begin{description}
 		\item[$q$-類似] $q \to 1$で通常の数学に戻るような諸概念の拡張 \pause
		\item[形式化] 人工言語に数学的な主張とその証明を翻訳し, 
		正しさを機械的に検証すること \pause
		\item[Coq] 形式化を行うためのソフトウェア \pause
	\end{description}
	形式化の意義： \pause
	\begin{itemize}
		\item 人間がチェックすることが難しい複雑な証明の正しさの保証 \pause
		\item 証明付きプログラミング \pause
	\end{itemize}
	本発表における$q$-類似の定義, 定理及びその証明はVictor Kac, Pokman Cheungの
	{\it Quantum Calculus}\cite{Kac}によるものだが, その形式化を行ったという点において
	独自性がある. 形式化したコード全体は
	\url{https://github.com/nakamurakaoru/q-analogue/tree/thesis}\cite{coq qana}
	にある(q\_analogu.v 1556行, q\_tool.v 331行).
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{$q$-類似}

\begin{frame}
  \tableofcontents[currentsection] 
\end{frame}

\begin{frame}{$q$-類似の概要}
  $q$-類似：以下の2つの条件をみたす数学の諸概念の一般化 \pause
  \begin{itemize}
    \item $q \to 1$とすると通常の数学に一致する \pause
    \item 実数パラメータ$q$, 実数上の関数$f$に対して
      \[
        D_q f(x) \coloneqq \frac{f(qx) - f(x)}{(q - 1) x}
      \]
    で定義される$q$-微分に対してうまく振る舞う \pause
  \end{itemize}
  $q$-類似を考える利点：あえてパラメータを増やすことで証明が簡単になる場合がある \pause
  \begin{itembox}{Jacobi の三重積(\cite{Kac} p35 Theorem 11.1)}
    $z$, $q \in \R$, $|q| < 1$として, 
    \[
      \sum_{n = -\infty}^{\infty} q^{n^2} z^n =
      \prod_{n = 1}^{\infty} (1 - q^{2n})(1 + q^{2n - 1}z)(1 + q^{2n - 1}z^{-1})
    \]
    が成り立つ. 
  \end{itembox}
\end{frame}

\begin{frame}{本節の目標}
	\begin{itembox}{$q$-Taylor展開}
		$f(x)$を, $N$次の実数係数多項式とする. 任意の$c\in\R$に対し, 
		\[
			f(x) = \sum_{j=0}^N (D_q^jf)(c)\frac{(x-c)^j_q}{[j]!}
		\]
		が成り立つ. 
	\end{itembox} \pause
	\begin{enumerate}
		\item $D_q$の定義 \pause
		\item $[n]$の定義 \pause
		\item $(x -c)^n_q$の定義
	\end{enumerate}
\end{frame}

\begin{frame}{$q$-微分}
  $q$-差分, $q$-微分の定義をする. 以下, $q$を$1$でない実数とする. \pause
  \begin{df}[\cite{Kac} p1 (1.1), p2 (1.5)]
    関数$f : \R \to \R$に対して, $f(x)$の$q$差分$d_q f(x)$を, 
    \[
      d_q f(x) \coloneqq f (qx) - f(x)
    \]
    と定める. 更に, $f(x)$の$q$微分$D_q f(x)$を, 
    \[
      D_q f(x) \coloneqq \frac{d_q f(x)}{d_q x} = \frac{f(qx) - f(x)}{(q - 1) x}
    \]
    と定める. 
  \end{df}
\end{frame}

\begin{frame}{自然数の$q$-類似}
	$f(x) = x^n$ ($n \in \N$)を定義に沿って$q$-微分する. \pause
	\begin{screen}
		\[
			D_q f(x) \coloneqq \frac{d_q f(x)}{d_q x} = \frac{f(qx) - f(x)}{(q - 1) x}
		\]
	\end{screen} \pause
	\[
		D_q x^n = \frac{(qx)^n - x^n}{(q - 1) x} \pause
					= \frac{q^n - 1}{q - 1} x^{n - 1}
	\] \pause
  
  通常の微分では, $(x^n)' = n x^{n - 1}$となることと比較して, 
  $n$の$q$-類似$[n]$を次のように定める(\cite{Kac} p2 (1.9)). \pause
  \[
    [n] = \frac{q^n - 1}{q - 1} \pause
    (= 1 + q + q^2 + \cdots q^{n - 1})
  \]
\end{frame}

\begin{frame}{$(x - a)^n$の$q$-類似} 
	\begin{df}[\cite{Kac} p8 Definition (3.4)]
	  $x$, $a \in \R$, $n \in \N$に対して, $(x - a)^n$の$q$-類似$(x - a)^n_q$を, 
	  \[
	  (x - a)^n_q = \begin{cases}
	                      1 & \text{if}\ n = 0 \\
	                      (x - a) (x - qa) \cdots (x - q^{n - 1} a) & \text{if}\ n \ge 1
	                    \end{cases}
	  \]
	  と定義する. 
	\end{df} \pause
	\begin{prop} \label{Dq_qbinom_nonneg}
	  $n\in\Z_{>0}$に対し, 
	  \[
	    D_q(x-a)^n_q = [n](x-a)^{n-1}_q
	  \]
	  が成り立つ. 
	\end{prop}
\end{frame}

\begin{frame}{$q$-Taylor展開}
	\begin{df}[\cite{Kac} p7 (3.1)]
		$n \in \N$について, 階乗の$q$-類似を以下のように定める. 
    \[
      [n]! \coloneqq \begin{cases}
                            1 & (n=0)\\
                            [n]\times[n-1]\times\cdots\times[1] & (n\ge1)
                          \end{cases}
    \]
  \end{df} \pause
  \begin{thm}[\cite{Kac} p12 Theorem 4.1] \label{q_Taylor}
	 $f(x)$を, $N$次の実数係数多項式とする. 任意の$c\in\R$に対し, 
	 \[
	   f(x) = \sum_{j=0}^N (D_q^jf)(c)\frac{(x-c)^j_q}{[j]!}
	 \]
	 が成り立つ. 
  \end{thm}
\end{frame}

\begin{frame}{Gauss's binomial formula}
	\begin{lem}[\cite{Kac} p15 Example (5.5)]
	  $n \in \Z_{>0}$について, 
	  \[
	    (x + a)^n_q = \sum_{j = 0}^n \qcoe{n}{j} q^{j (j - 1)/2} a^j x^{n - j}
	  \]
	  が成り立つ. この式は Gauss's binomial formula と呼ばれる. 
	\end{lem} \pause
	\begin{df}[\cite{Kac} p12 (4.5)]
		$n \ge j$をみたす$n$, $j \in \N$について, 二項係数の$q$-類似を以下のように定める. 
		\[
			\qcoe{n}{j} \coloneqq \frac{[n]!}{[j]![n - j]!}
		\]
	\end{df}
%\bpf
%  $f = (x + a)^n_q$とすると, 任意の正整数$j \le n$に対して, 
%  \[
%    (D_q ^j f) (x) = [n] [n - 1] [n - j + 1] (x + a)^{n - j}_q
%  \]
%  であり, また
%  \[
%    (x + a)^m_q = (x + a) (x + qa) \cdots (x + q^{m - 1} a)
%  \]
%  から, $(0 + a)^m_q = a \cdot qa \cdots q^{m - 1}a = q^{m (m - 1)/2}a^m$となるので, 
%  \[
%    (D_q^j f) (0) = [n] [n - 1] \cdots [n - j +1]q^{(n - j) (n - j - 1)/2} a^{n - j}
%  \]
%  が成り立つ. よって, Theorem \ref{q_Taylor} において, $f = (x + a)^n_q$, $c = 0$として, 
%  \[
%    (x + a)^n_q = \sum_{j = 0}^n \qcoe{n}{j} q^{(n - j) (n - j - 1)/2} a^{n - j} x^j
%  \]
%  が得られる. この式の右辺において$j$を$n - j$に置き換えることで, 
%  \[
%    \qcoe{n}{n - j} = \frac{[n]!}{[n - j]![n - (n - j)]!} = \frac{[n]!}{[j]![n - j]!} = \qcoe{n}{j}
%  \]
%  に注意すれば, 
%  \[
%    (x - a)^n_q = \sum_{j = 0}^n \qcoe{n}{j} q^{j (j - 1)/2} a^j x^{n - j}
%  \]
%  が成り立つ. 
%\epf
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coq}

\begin{frame}
  \tableofcontents[currentsection] 
\end{frame}

\begin{frame}{Coq の使い方 コマンド}
  Coq に与える命令はコマンドとタクティックの2種類がある. \pause
	\begin{description}
	  \item[\tt Require Import] ライブラリを読み込む.
	%    {\tt From mathcomp Require Import ssreflect}
	%    であれば, ライブラリ群 mathcomp から ssreflect を読み込んでいる.
	%  \item[\tt Section / End]
	%    {\tt Section [セクション名]}, {\tt End [セクション名]}でセクションを作ることができ, 
	%    そのセクション内共通のコンテキストを宣言できる. 
	  \item[\tt Variable] 特定の型を持つ変数を宣言する
	%    {\tt Section/End}コマンドと組み合わせることで, {\tt End}まで同じ意味で扱われ, 
	%    {\tt End}以降は効力を失う. 
	%    同時に複数の変数を宣言することもできる. その場合は
	%    
	%    {\tt Variables [変数] [変数] $\cdots$ [変数]$\colon$[型]}
	%    
	%    と書く(ただし, Coq にとっては{Variable}と{Variables}に違いは無い).    
	%  \item[\tt Hypothesis]
	%    {\tt Hypothesis [仮定名]$\colon$[仮定]}で仮定を置くことができる. {\tt Variable}同様, 
	%    {\tt Section/End}と組み合わせることで, セクション内共通の仮定を置くことができる. 
	  \item[\tt Definition] 新たに関数を定義する.
	%    \begin{lstlisting}{Coq}
	%Definition dq (f : R -> R) x := f (q * x) - f x. \end{lstlisting}
	%    であれば, {\tt dq}が定義の名前, {\tt f}, {\tt x}が引数, {\tt R -> R}が{\tt f}の型であり, 
	%    {\tt f (q * x) - f x}が{\tt dq}を定義する式である. また, {\tt x}と{\tt dq}そのものの型は
	%    推論できるため省略できる. 
	  \item[\tt Fixpoint] 再帰関数を定義する. 
	  	停止性が保証されていない関数を定義することはできない.
	%    
	%    {\tt Fixpoint [関数名] ([引数]$\colon$[引数の型])$\colon$[関数の型] := 
	%    [定義中の関数を含む定義式]}
	%    
	%    と書く. 停止しない関数を認めてしまうと矛盾が生じるため, 停止性が保証されていない
	%    関数を定義することはできない. 
	  \item[\tt Lemma] 補題を宣言する. 
	%    \begin{lstlisting}{Coq}
	%Lemma Dq_pow n x : x != 0 -> Dq (fun x => x ^ n) x = qnat n * x ^ (n - 1). \end{lstlisting}
	%    であれば, {\tt Dq\_pow}が補題名, {\tt n}, {\tt x}が引数, {\tt :}以降が補題の主張である. 
	%    
	    {\tt Lemma}の代わりに{\tt Theorem}, {\tt Corollary}等でも同じ機能をもつ. 
	  \item[\tt Proof/Qed]
	    {\tt Proof}は{\tt Lemma}の後に書いて補題の主張と証明を分ける.  
	    証明を完了させて{\tt Qed}を書くことで Coq に補題を登録することができ, 他の補題の
	    証明に使えるようになる. 
	\end{description} \pause
	タクティックは{\tt Proof...Qed}の間に使われる. 
	よく使われるタクティックは{\tt move}, {\tt apply}, {\tt rewrite}の3つ.
\end{frame}

\begin{frame}[fragile]{Coq の使い方 代入計算}
	\begin{screen}
	自然数$m$, $n$について
	\[
		m = 0 \Longrightarrow n + m = n
	\]
	\end{screen} \pause
	\begin{lstlisting}{Coq}
Lemma substitution m n : m = 0 -> n + m = n. \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Coq の使い方 代入計算}
	\begin{screen}
		\begin{lstlisting}{Coq}
    1 subgoal
    m, n : nat
    -------------------------------
    m = 0 -> n + m = n \end{lstlisting}
	\end{screen} \pause
	タクティック：{\tt move=> Hm}
\end{frame}

\begin{frame}[fragile]{Coq の使い方 代入計算}
	\begin{screen}
	\begin{lstlisting}{Coq}
    1 subgoal
    m, n : nat
    Hm : m = 0
    -------------------------------
    n + m = 0 \end{lstlisting}
    \end{screen} \pause
    タクティック：{\tt rewrite Hm}
\end{frame}

\begin{frame}[fragile]{Coq の使い方 代入計算}
	\begin{screen}
		\begin{lstlisting}{Coq}
    1 subgoal
    m, n : nat
    Hm : m = 0
    -------------------------------
    n + 0 = n \end{lstlisting}
	\end{screen} \pause
	タクティック：{\tt rewrite addn0}
\end{frame}

\begin{frame}[fragile]{Coq の使い方 代入計算}
	\begin{screen}
		\begin{lstlisting}{Coq}
    1 subgoal
    m, n : nat
    Hm : m = 0
    -------------------------------
    n = n \end{lstlisting}
	\end{screen} \pause
	タクティック：{\tt done}
\end{frame}

\begin{frame}[fragile]{Coq の使い方 代入計算}
	\begin{screen}
		\begin{lstlisting}{Coq}
    No more subgoals.  \end{lstlisting}
	\end{screen} \pause
	コマンド：{\tt Qed}
\end{frame}

\begin{frame}[fragile]{Coq の使い方 代入計算}
	\begin{lstlisting}{Coq}
Lemma substitution m n : m = 0 -> n + m = n.
Proof.
  move=> Hm.
  rewrite Hm.
  rewrite addn0.
  by [].
Qed. \end{lstlisting}
\end{frame}

%\begin{frame}{Coq の使い方 タクティック}
%である. 
%\begin{description}
%  \item[\tt move]
%    {\tt move=> H}でゴールの前提に{\tt H}という名前をつけてコンテクストに移動する. 
%    また{\tt move$\colon$H}で補題{\tt H}もしくはコンテクストに存在する{\tt H}をゴールの
%    前提に移す. 
%  \item[\tt apply]
%    補題{\it lem}が{\tt P1 $\to$ P2}という形で, ゴールが{\tt P2}のとき, 
%    {\tt apply {\it lem}}でゴールを{\tt P1}に変える. 
%    コンテクストの仮定{\tt H}が{\tt P1 $\to P2$}であれば{\tt apply H}で同じことができる. 
%  \item[\tt rewrite]
%    {\it def}が定義のとき, {\tt rewrite /{\it def}}でゴールに出現している{\it def}を展開する. 
%    
%    また, 補題{\it lem}が{\tt A = B}という形のとき, {\tt rewrite {\it lem}}でゴールに出現する
%    {\tt A}を{\tt B}に書き換える(ただし, {\it lem}が{\tt H $\to$ (A = B)}という形であるとき, 
%    新たなゴールとして{\tt H}が追加される). 更に, {\tt rewrite {\it lem} in H}で, コンテクストの{\tt H}に
%    出現する{\tt A}を{\tt B}に書き換える. {\tt apply}と同じく, 使いたい等式が仮定にある場合も
%    同じように使える. 更に, {\tt rewrite}は繰り返し回数や適用箇所を指定できる.
%    \begin{description}
%      \item[\tt rewrite !{\it lem}] {\it lem}による書き換えを可能な限り繰り返す. 
%        ただし場合によっては繰り返しが終わらないことに注意
%        ($x + y$を$y + x$に書き換える補題を使う場合など).
%      \item[\tt rewrite n!{\it lem}] {\it lem}による書き換えを$n$回限り繰り返す.
%      \item[\tt rewrite ?{\it lem}] {\it lem}による書き換えを$0$回または$1$回行う. 
%        直前のタクティックでゴールが増える場合に特に有効. 
%      \item[\tt rewrite -{\it lem}] 逆向きに{\it lem}による書き換えを行う. 
%        つまり, {\it lem}が{\tt A = B}のとき, ゴールの{\tt B}を{\tt A}に書き換える. 
%      \item[\tt rewrite \{n\}{\it lem}] {\it lem}で書き換えられる場所のうち
%        $n$番目のみを書き換える. 
%      \item[{\tt rewrite [条件] {\it lem}}] 条件に一致する場所を{\it lem}で書き換える.
%      \item[\tt rewrite (\_ : A = B)] ゴールの{\tt A}を{\tt B}に書き換える. 
%        {\tt A = B}がゴールに追加される. この書き方の場合は補題を引数にとらない. 
%    \end{description}
%    このような, タクティックの前後に書いてその機能を拡張するものをタクティカルと言う. 
%    {\tt move=>}の{\tt =>}や{\tt move$\colon$}の{\tt $\colon$}もタクティカルである. 
%\end{description}\end{frame}

%\begin{frame}{Coq の使い方4 代入計算}
%  代入に関する簡単な計算を形式化
%\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{$q$-類似の形式化}

\begin{frame}
  \tableofcontents[currentsection] 
\end{frame}

\begin{frame}[fragile]{本節の目標} \pause
	\begin{lstlisting}{Coq}
Theorem q_Taylorp n (f : {poly R}) c :
  (forall n, qfact n != 0) ->
  size f = n.+1 ->
  f = \sum_(0 <= i < n.+1)
    ((Dqp' \^ i) f).[c] *: (qbinom_pos_poly c i / (qfact i)%:P).
    
Theorem Gauss_binomial a n : (forall n, qfact n != 0) ->
  qbinom_pos_poly (-a) n =
    \sum_(0 <= i < n.+1)
      (qbicoef n i * q ^+ (i * (i - 1))./2 * a ^+ i) *: 'X^(n - i). \end{lstlisting} \pause
	\begin{itemize}
		\item $q$-微分の形式化 \pause
		\item $[n]$の形式化 \pause
		\item $(x - a)^n_q$の形式化 \pause
		\item 関数から多項式へ
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{$q$-微分の形式化}
	\begin{screen}
		\[
			d_q f (x) \coloneqq f(qx) - f(x) \quad D_q f (x) \coloneqq \frac{d_q f(x)}{d_q x}
		\]
	\end{screen} \pause
	\begin{lstlisting}{Coq}
Variables (R : rcfType) (q : R).
Hypothesis Hq : q - 1 != 0.

Notation "f // g" := (fun x => f x / g x) (at level 40).

Definition dq (f : R -> R) x := f (q * x) - f x.
Definition Dq f := dq f // dq id. \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{$[n]$の形式化}
	\begin{screen}
		\[
			[n] \coloneqq \frac{q^n - 1}{q - 1} \quad
			D_q x^n = \frac{(qx)^n - x^n}{(q - 1) x} = \frac{q^n - 1}{q - 1} \cdot \frac{x^n}{x}
							= [n] x^{n - 1}
		\]
	\end{screen} \pause
	\begin{lstlisting}{Coq}
Definition qnat n : R := (q ^ n - 1) / (q - 1).

Lemma Dq_pow n x : x != 0 ->
  Dq (fun x => x ^ n) x = qnat n * x ^ (n - 1).
Proof.
  move=> Hx.
  rewrite /Dq /dq /qnat.
  rewrite -{4}(mul1r x) -mulrBl expfzMl -add_div;
    last by apply mulf_neq0.
  rewrite [in x ^ n](_ : n = (n -1) +1) //; last by rewrite subrK.
  rewrite expfzDr ?expr1z ?mulrA -?mulNr ?red_frac_r ?add_div //.
  rewrite -{2}[x ^ (n - 1)]mul1r -mulrBl mulrC mulrA.
  by rewrite [in (q - 1)^-1 * (q ^ n - 1)] mulrC.
Qed. \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{$(x - a)^n_q$の形式化}
	\begin{screen}
		\begin{align*}
			(x - a)^n_q &\coloneqq \begin{cases}
	                      1 & \text{if}\ n = 0 \\
	                      (x - a) (x - qa) \cdots (x - q^{n - 1} a) & \text{if}\ n \ge 1
	                    \end{cases} \\
			D_q (x - a)^n_q &= [n](x - a)^{n - 1}_q \quad (n \in \Z_{>0})
		\end{align*}
	\end{screen} \pause
	\begin{lstlisting}{Coq}
Fixpoint qbinom_pos a n x :=
  match n with
  | 0 => 1
  | n0.+1 => (qbinom_pos a n0 x) * (x - q ^ n0 * a)
  end. 
  
Theorem Dq_qbinom_pos a n x : x != 0 ->
  Dq (qbinom_pos a n.+1) x = qnat n.+1 * qbinom_pos a n x. \end{lstlisting}
\end{frame}

%\begin{frame}{\tt Dq qbinom\_pos}
%  \[
%    D_q (x - a)^n_q = [n] (x - a)^n_q
%  \]
%\end{frame}
%
%\begin{frame}{\tt qbinom}  
%\end{frame}

\begin{frame}{関数から多項式へ} \pause
	\textbf{約分に条件が必要ない} \pause
	
	$x / x = 1$を計算するとき
	\begin{itemize}
		\item 実数 $\cdots$ $x \ne 0$が必要 \pause
		\item 多項式 $\cdots$ $x$は単項式なので自動的に $x \ne 0$(ゼロ多項式) \pause
	\end{itemize}
	$\to$多項式で考えれば約分した後でも$x = 0$での値が求められる. \pause
	\[
	  D_q (x - a)^n_q = [n](x - a)^{n - 1}_q
	\]
	という計算をした後でも$0$での値が求められる. \pause
	
	$\to$Gauss's binomial formulaの証明に必要
\end{frame}

%\begin{frame}{関数から多項式へ} \pause
%	\textbf{$q = 0$のとき高階$D_q$が定義できる} \pause
%	\begin{align*}
%		(D_q ^2 f) (x) &= (D_0 ^2 f) (x) = (D_0 (D_0 f)) (x) \\
%								&= D_0 \left(x \mapsto \frac{f (0 x) - f(x)}{(0 - 1)x} \right) (x)
%									= D_0 \left(x \mapsto \frac{f(x) - f(0)}{x} \right) (x) \\
%								&= (D_0 F) (x) \quad
%									(F \coloneqq x \mapsto \frac{f(x) - f(0)}{x})\\
%								&= \left( x \mapsto \frac{F(x) - F(0)}{x} \right) (x)
%									= \frac{F(x) - F(0)}{x}
%	\end{align*}
%	\[
%		F(0) = \frac{f(0) - f(0)}{0} = \frac{0}{0}
%	\]
%	$d_q$が各点ごとに定義してあることが問題
%	
%	$\to$多項式の係数を変化させることで定義すれば$q = 0$かどうかに関らず高階$q$-微分を
%	定義できる
%\end{frame}

%\begin{frame}{Coq での多項式}
%
%	{\tt T}$\colon${\tt ringType}のとき, {\tt \{poly T\}} $\cdots$ {\tt T}係数多項式全体 
%	\pause
%	
%	{\tt \{poly R\}}も{\tt ringType}の構造を持っている \pause
%	\begin{description}
%	  \item[\tt \textbackslash poly\_(i < n) E(i)] 次数が$n - 1$次以下, $i$次の係数が$E(i)$
%	    である多項式
%	  \item[\tt c\%:P] 定数$c$のみからなる単項式
%	  \item[\tt 'X] 変数$x$のみからなる単項式
%	  \item[\tt p`\_i] 多項式$p$の$i$次の係数 
%	  \item[\tt size p] 多項式$p$の次数$+1$
%	  \item[{\tt p.[x]}] 多項式$p$の$x$での値 
%	\end{description}
%\end{frame}

\begin{frame}[fragile]{多項式での再定義}
	$q$-差分
	\begin{lstlisting}{Coq}
Definition scale_var (p : {poly R}):=
 \poly_(i < size p) (q ^ i * p`_i).
Definition dqp p := scale_var p - p. \end{lstlisting} \pause
{\tt scale\_var} $\cdots$ $p \mapsto$ ($p$の$i$次の係数を$q^i$倍した多項式) \pause

	$q$-微分
	\begin{lstlisting}{Coq}
Definition Dqp p := dqp p %/ dqp 'X.
Definition Dqp' (p : {poly R}) :=
  \poly_(i < size p) (qnat (i.+1) * p`_i.+1). \end{lstlisting} \pause
	$(x - a)^n_q$
	\begin{lstlisting}{Coq}
Fixpoint qbinom_pos_poly a n :=
  match n with
  | 0 => 1
  | n0.+1 => (qbinom_pos_poly a n0) * ('X - (q ^ n0 * a)%:P)
  end. \end{lstlisting}
\end{frame}

%\begin{frame}[fragile]{多項式に対する$q$-微分の再定義}
%	多項式に対する$q$-差分 \pause
%	\begin{lstlisting}{Coq}
%Definition scale_var (p : {poly R}):=
%  \poly_(i < size p) (q ^ i * p`_i).
%Definition dqp p := scale_var p - p. 
%\end{lstlisting} \pause
%	多項式に対する$q$-微分 \pause
%	\begin{lstlisting}{Coq}
%Definition Dqp p := dqp p %/ dqp 'X.
%\end{lstlisting}
%	{\tt p \%/ p'}は多項式{\tt p}を多項式{\tt p'}で割った商 \pause
%	
%	$\to$余りが$0$でない可能性があるため, $q$-微分の正しい形式化である保証がない \pause
%	\begin{lstlisting}{Coq}
%Lemma Dqp_ok p : dqp 'X %| dqp p.
%\end{lstlisting}
%	{\tt p' \%| p} $\cdots$ {\tt p}が{\tt p'}で割り切れる
%\end{frame}

%\begin{frame}[fragile]{多項式に対する$q$-微分の再定義}
%	扱いやすさのため, {\tt `X}で約分した形を使う
%	\begin{lstlisting}{Coq}
%Definition Dqp' (p : {poly R}) :=
%  \poly_(i < size p) (qnat (i.+1) * p`_i.+1).
%\end{lstlisting} \pause
%	{\tt Dqp}と{\tt Dqp'}は等しく, また{\tt Dqp'}と多項式に対する{\tt Dq}は等しい
%	\begin{lstlisting}{Coq}
%Lemma Dqp_Dqp'E p : Dqp p = Dqp' p.
% 
%Definition ap_op_poly (D : (R -> R) -> (R -> R)) (p : {poly R}) :=
%  D (fun (x : R) => p.[x]).
%Notation "D # p" := (ap_op_poly D p) (at level 49).
%Lemma Dqp'_DqE p x : x != 0 -> (Dqp' p).[x] = (Dq # p) x.\end{lstlisting}
%\end{frame}

%\begin{frame}[fragile]{多項式としての$(x - a)^n_q$の再定義}
%	\begin{lstlisting}{Coq}
%Fixpoint qbinom_pos_poly a n :=
%  match n with
%  | 0 => 1
%  | n0.+1 => (qbinom_pos_poly a n0) * ('X - (q ^ n0 * a)%:P)
%  end. \end{lstlisting} \pause
%	多項式の{\tt x}での値は元の定義の{\tt qbinom\_pos}と等しい
%	\begin{lstlisting}{Coq}
%Lemma qbinom_posE a n x :
%  qbinom_pos a n x = (qbinom_pos_poly a n).[x].
%\end{lstlisting} \pause
%	{\tt Dqp}と{\tt qbinom\_pos\_poly}に対しても
%	\begin{screen}
%		\[
%			D_q (x - a)^n_q = [n] (x - a)^n_q
%		\]
%	\end{screen}
%	が成り立つ \pause
%	\begin{lstlisting}{Coq}
%Lemma Dqp'_qbinom_poly a n :
%  Dqp' (qbinom_pos_poly a n.+1) =
%    (qnat n.+1) *: (qbinom_pos_poly a n).\end{lstlisting}
%\end{frame}

\begin{frame}[fragile]{$q$-Taylor展開の形式化}
	\begin{screen}
		\[
			f(x) = \sum_{j=0}^N (D_q^jf)(c)\frac{(x-c)^j_q}{[j]!}
		\]
	\end{screen} \pause
	\begin{lstlisting}{Coq}
Fixpoint qfact n :=
  match n with
  | 0 => 1
  | n0.+1 => qfact n0 * qnat n0.+1
  end.

Theorem q_Taylorp n (f : {poly R}) c :
  (forall n, qfact n != 0) ->
  size f = n.+1 ->
  f = \sum_(0 <= i < n.+1)
    ((Dqp' \^ i) f).[c] *: (qbinom_pos_poly c i / (qfact i)%:P).
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Gauss's binomial formula の形式化}
	\begin{screen}
		\[
			(x + a)^n_q = \sum_{j = 0}^n \qcoe{n}{j} q^{j (j - 1)/2} a^j x^{n - j}
		\]
	\end{screen} \pause
	\begin{lstlisting}{Coq}
Definition qbicoef n j := qfact n / (qfact j * qfact (n - j)).

Theorem Gauss_binomial a n : (forall n, qfact n != 0) ->
  qbinom_pos_poly (-a) n =
    \sum_(0 <= i < n.+1)
      (qbicoef n i * q ^+ (i * (i - 1))./2 * a ^+ i) *: 'X^(n - i). \end{lstlisting}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{今後の展望}

\begin{frame}
	\tableofcontents[currentsection] 
\end{frame}

\begin{frame}{今後の展望}
	現在開発中のライブラリ mathcomp analysis\cite{coq ana} の利用 \pause
	\begin{itemize}
		\item $q \to 1$で通常の数学に戻ることの形式化 \pause
		\item 無限和に関する形式化 \pause
		
		$\to$Gauss's binomial formulaの拡張, 
		$q$-指数関数, $q$-三角関数
	\end{itemize}	
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Appendix}

\begin{frame}
	\tableofcontents[currentsection] 
\end{frame}

\begin{frame}{Appendix $q$-微分の諸性質}
	線形性(\cite{Kac} p2)
	\[
		D_q (af(x) + bg(x)) = a D_q f(x) + b D_q g(x)
	\]
	積の微分法則(\cite{Kac} p3 (1.11), (1.12))
	\begin{align*}
		D_q (f(x) g(x)) &= f(qx) D_q g(x) + g(x) D_q f(x) \\
		D_q (f(x) g(x)) &= f(x) D_q g(x) + g(qx) D_q f(x)
	\end{align*}
	商の微分法則(\cite{Kac} p3 (1.13), (1.14))
	\begin{align*}
		D_q \left( \frac{f(x)}{g(x)} \right) &= \frac{g(x) D_q f(x) - f(x) D_q g(x)}{g(x) g(qx)} \\
		D_q \left( \frac{f(x)}{g(x)} \right) &= \frac{g(qx) D_q f(x) - f(qx) D_q g(x)}{g(x) g(qx)}
	\end{align*}
\end{frame}

\begin{frame}{Appendix $(x -a)^n_q$の指数法則と負冪}
	\begin{prop}[\cite{Kac} p8 (3.6)] \label{q_exp_low}
	  $x,a\in\R$, $m,n\in\Z_{>0}$について, 
	  \[
	    (x-a)^{m+n}_q = (x-a)^m_q (x-q^ma)^n_q
	  \]
	  が成り立つ. 
	\end{prop}
	\begin{df}[\cite{Kac} p9 (3.7)] \label{qbinom_neg}
	  $x$, $a \in \R$, $l\in\Z_{>0}$とする. このとき, 
	  \[
	    (x-a)^{-l}_q \coloneqq \frac{1}{(x-q^{-l}a)^l_q}
	  \]
	  と定める. 
	\end{df}
\end{frame}

\begin{frame}{Appendix $q$-指数関数, $q$-三角関数}
	$q$-指数関数\cite{Kac} 9
	\begin{align*}
		e^x_q \coloneqq \sum_{j = 0}^{\infty} \frac{x^j}{[j]!} \quad
		E^x_q \coloneqq \sum_{j = 0}^{\infty} q^{j(j - 1) / 2} \frac{x^j}{[j]!} \\
		D_q e^x_q = e^x_q \quad D_q E^x_q = E^{qx}_x \\
		e^x_q e^y_q = e^{x + y}_q \quad (\text{if}\ yx = qxy) \\
		e^x_q E^{-x}_q = 1 \quad e^x_{1/q} = E^x_q
	\end{align*}
	$q$-三角関数\cite{Kac} 10
	\begin{align*}
		\sin_q x \coloneqq \frac{e^{ix}_q - e^{-ix}_q}{2i} \quad
		\cos_q x \coloneqq \frac{e^{ix}_q + e^{-ix}_q}{2} \\
		\textrm{Sin}_q x \coloneqq \frac{E^{ix}_q - E^{-ix}_q}{2i} \quad
		\textrm{Cos}_q x \coloneqq \frac{E^{ix}_q + E^{-ix}_q}{2} \\
		\cos_q x \textrm{Cos}_q x + \sin_q x \textrm{Sin}_q x = 1
	\end{align*}
\end{frame}

\begin{frame}[fragile]{Appendix モーダスポーネンス}
	「命題$P$, $Q$について, $P$かつ$P \Lra Q$であれば, $Q$が成り立つ」 \pause
	\begin{lstlisting}{Coq}
From mathcomp Require Import ssreflect.

Lemma modus_ponens (P Q : Prop) : P /\ (P ->Q) -> Q. \end{lstlisting} \pause
	{\tt Prop}は Coq での命題全体を表す型, $\wedge$は「かつ」を表す
\end{frame}

\begin{frame}[fragile]{Appendix モーダスポーネンス}
	\begin{screen}
	  \begin{lstlisting}{Coq}
1 subgoal
P, Q : Prop
-------------------------------
P /\ (P -> Q) -> Q \end{lstlisting}
	\end{screen} \pause
	タクティック：{\tt move=> []}
\end{frame}

\begin{frame}[fragile]{Appendix モーダスポーネンス}
	\begin{screen}
	  \begin{lstlisting}{Coq}
1 subgoal
P, Q : Prop
-------------------------------
P -> (P -> Q) -> Q \end{lstlisting}
	\end{screen} \pause
	タクティック：{\tt move=> p}
\end{frame}

\begin{frame}[fragile]{Appendix モーダスポーネンス}
	\begin{screen}
	  \begin{lstlisting}{Coq}
1 subgoal
P, Q : Prop
p : P
-------------------------------
(P -> Q) -> Q \end{lstlisting}
	\end{screen} \pause
	タクティック：{\tt move=> pq}
\end{frame}

\begin{frame}[fragile]{Appendix モーダスポーネンス}
	\begin{screen}
	  \begin{lstlisting}{Coq}
1 subgoal
P, Q : Prop
p : P
pq : P -> Q
-------------------------------
Q \end{lstlisting}
	\end{screen} \pause
	タクティック：{\tt apply pq}
\end{frame}

\begin{frame}[fragile]{Appendix モーダスポーネンス}
	\begin{screen}
	  \begin{lstlisting}{Coq}
1 subgoal
P, Q : Prop
p : P
pq : P -> Q
-------------------------------
P \end{lstlisting}
	\end{screen} \pause
	タクティック：{\tt done}
\end{frame}

\begin{frame}[fragile]{Appendix モーダスポーネンス}
	\begin{screen}
	  \begin{lstlisting}{Coq}
  No more subgoals. \end{lstlisting}
	\end{screen} \pause
	コマンド：{\tt Qed}
\end{frame}

\begin{frame}[fragile]{Appendix モーダスポーネンス}
	\begin{lstlisting}{Coq}
Lemma modus_ponens (P Q : Prop) : P /\ (P -> Q) -> Q.
Proof.
  move=> [].
  move=> p.
  move=> pq.
  apply pq.
  done.
Qed. \end{lstlisting}
\end{frame}

\begin{frame}{Appendix mathcomp の構造}
	標準ライブラリ\cite{coq sl}に加えて mathcomp \cite{coq mc}を用いる. \pause
	
	mathcomp の型には階層構造があり, より一般の型の性質を引き継ぐ. \pause
	
	今回は実数として{\tt rcfType}(Real Closed Field：実閉体)を使う. \pause
	\begin{align*}
		{\tt eqType} &\to {\tt choiceType} \\
		                  &\to {\tt zmodType} \to {\tt ringType} \to 
		                          {\tt comRingType} \to {\tt comUnitRingType}\\
							  &\to {\tt idomainType} \to {\tt fieldType}\\
		                  &\to {\tt numFieldType} \to {\tt realFieldType} \to {\tt rcfType}
	\end{align*} \pause
	{\tt ringType}, {\tt fieldType}の性質が重要
\end{frame}

\begin{frame}{Coq の多項式}

	{\tt T}$\colon${\tt ringType}のとき, {\tt \{poly T\}} $\cdots$ {\tt T}係数多項式全体 
	
	{\tt \{poly R\}}も{\tt ringType}の構造を持っている
	\begin{description}
	  \item[\tt \textbackslash poly\_(i < n) E(i)] 次数が$n - 1$次以下, $i$次の係数が$E(i)$
	    である多項式
	  \item[\tt c\%:P] 定数$c$のみからなる単項式
	  \item[\tt 'X] 変数$x$のみからなる単項式
	  \item[\tt p`\_i] 多項式$p$の$i$次の係数 
	  \item[\tt size p] 多項式$p$の次数$+1$
	  \item[{\tt p.[x]}] 多項式$p$の$x$での値 
	\end{description}
\end{frame}

\begin{frame}[fragile]{Appendix {\tt Dqp}の正当性}
	\begin{lstlisting}{Coq}
Definition Dqp p := dqp p %/ dqp 'X.
\end{lstlisting}
	{\tt p \%/ p'}は多項式{\tt p}を多項式{\tt p'}で割った商
	
	$\to$余りが$0$でない可能性があるため, $q$-微分の正しい形式化である保証がない
	\begin{lstlisting}{Coq}
Lemma Dqp_ok p : dqp 'X %| dqp p.

Import FracField.

Local Notation tofrac := (@tofrac [idomainType of {poly R}]).
Local Notation "x %:F" := (tofrac x).

Theorem Dqp_ok_frac p : (dqp p)%:F / (dqp 'X)%:F = (Dqp p)%:F.
\end{lstlisting}
	{\tt p' \%| p} $\cdots$ {\tt p}が{\tt p'}で割り切れる
\end{frame}

\begin{frame}[fragile]{Appendix {\tt Dq}と{\tt Dqp}}
	\begin{lstlisting}{Coq}
Definition ap_op_poly (D : (R -> R) -> (R -> R)) (p : {poly R}) :=
  D (fun (x : R) => p.[x]).
Notation "D # p" := (ap_op_poly D p) (at level 49).

Lemma dqp_dqE p x : (dqp p).[x] = (dq # p) x. 

Lemma Dqp_Dqp'E p : Dqp p = Dqp' p.
Lemma Dqp'_DqE p x : x != 0 -> (Dqp' p).[x] = (Dq # p) x.

Lemma Dqp'_qbinom_poly a n :
  Dqp' (qbinom_pos_poly a n.+1) =
    (qnat n.+1) *: (qbinom_pos_poly a n).\end{lstlisting}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{9}
	\bibitem{coq sl} Coq Team, {\it The Coq Standard Library}, 
		\url{https://coq.inria.fr/distrib/current/stdlib/}, 2023.
	\bibitem{Kac} Victor Kac, Pokman Cheung, {\it{Quantum Calculus}}, Springer, 2001.
	\bibitem{coq mc} Mathematical Components Team, {\it Mathematical Components}, 		
		\url{https://github.com/math-comp/math-comp}, 2023.
	\bibitem{coq ana} Mathematical Components Team, 
		{\it Mathematical Components compliant Analysis Library}, 
			\url{https://github.com/math-comp/analysis}, 2023.
	\bibitem{coq qana} 中村 薫, {\it q-analogue}, 
		\url{https://github.com/nakamurakaoru/q-analogue/tree/thesis}, 2023.
%  \bibitem{bib1} H.P.Barendregt, {\it{Lambda Calculi with Types}}
\end{thebibliography}
\end{document}